# Data Structures - 数据结构

> 如何组织和存储数据？选择合适的数据结构是高效编程的关键

## 📚 什么是数据结构？

**数据结构**是组织和存储数据的方式，决定了：
- 如何访问数据
- 如何修改数据
- 操作的效率如何

**好的数据结构选择 = 高效的算法 + 简洁的代码**

---

## 🗺️ 学习内容

### [数组与列表](arrays-lists.md) 📊
最基础的线性数据结构

- **数组 (Array)** - 连续内存，固定大小，O(1)访问
- **动态数组 (Dynamic Array)** - 可变大小的数组
- **链表 (Linked List)** - 节点链接，灵活插入删除
- **双向链表 (Doubly Linked List)** - 双向遍历

**应用场景**：存储有序数据、实现其他数据结构的基础

**时间复杂度对比**：
| 操作 | 数组 | 链表 |
|-----|------|------|
| 访问 | O(1) | O(n) |
| 插入 | O(n) | O(1) |
| 删除 | O(n) | O(1) |

---

### [栈与队列](stacks-queues.md) 📚
特殊的线性结构，限制访问方式

- **栈 (Stack)** - 后进先出 (LIFO)，像叠盘子
- **队列 (Queue)** - 先进先出 (FIFO)，像排队
- **双端队列 (Deque)** - 两端都可操作
- **优先队列 (Priority Queue)** - 按优先级出队

**应用场景**：
- 栈：函数调用、括号匹配、浏览器后退
- 队列：任务调度、消息队列、广度优先搜索

---

### [树与图](trees-graphs.md) 🌳
分层和网络结构

**树结构**：
- **二叉树 (Binary Tree)** - 每个节点最多两个子节点
- **二叉搜索树 (BST)** - 有序的二叉树
- **平衡树 (AVL, Red-Black Tree)** - 自平衡，保持高度
- **堆 (Heap)** - 完全二叉树，实现优先队列
- **字典树 (Trie)** - 字符串前缀树

**图结构**：
- **有向图 vs 无向图**
- **加权图 vs 无权图**
- **邻接矩阵 vs 邻接表**

**应用场景**：
- 树：文件系统、DOM树、决策树、数据库索引
- 图：社交网络、地图导航、依赖关系

---

### [哈希表](hash-tables.md) #️⃣
快速查找的利器

- **哈希函数** - 将键映射到索引
- **冲突解决** - 链地址法、开放寻址
- **负载因子** - 影响性能的关键
- **哈希集合 vs 哈希映射**

**应用场景**：
- 缓存实现
- 数据库索引
- 快速查找（词频统计、去重）

**时间复杂度**：平均 O(1)，最坏 O(n)

---

## 🎯 如何选择数据结构？

### 按操作类型选择

| 需求 | 推荐数据结构 |
|-----|------------|
| **频繁随机访问** | 数组 |
| **频繁插入删除** | 链表 |
| **LIFO操作** | 栈 |
| **FIFO操作** | 队列 |
| **快速查找** | 哈希表 |
| **有序数据** | 二叉搜索树 |
| **层级关系** | 树 |
| **网络关系** | 图 |

### 按性能要求选择

**时间优先**：
- 查找 → 哈希表 O(1)
- 访问 → 数组 O(1)
- 最小值 → 堆 O(1)

**空间优先**：
- 稀疏数据 → 哈希表
- 密集数据 → 数组

---

## 📊 时间复杂度速查表

| 数据结构 | 访问 | 查找 | 插入 | 删除 | 空间 |
|---------|------|------|------|------|------|
| **数组** | O(1) | O(n) | O(n) | O(n) | O(n) |
| **链表** | O(n) | O(n) | O(1) | O(1) | O(n) |
| **栈** | O(n) | O(n) | O(1) | O(1) | O(n) |
| **队列** | O(n) | O(n) | O(1) | O(1) | O(n) |
| **哈希表** | - | O(1)* | O(1)* | O(1)* | O(n) |
| **二叉搜索树** | O(log n)* | O(log n)* | O(log n)* | O(log n)* | O(n) |
| **堆** | O(1)** | O(n) | O(log n) | O(log n) | O(n) |

\* 平均情况，最坏可能是 O(n)
\** 只能访问最大/最小值

---

## 💡 学习建议

### 1. 理解概念优先
不要急于实现，先理解：
- 这个数据结构解决什么问题？
- 为什么这样设计？
- 适用于什么场景？

### 2. 动手实现
自己实现一遍，加深理解：
```python
# 实现简单的栈
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()
```

### 3. 分析复杂度
每个操作都思考时间和空间复杂度

### 4. 实际应用
在项目中使用，理解何时该用哪个

### 5. 可视化工具
- [VisuAlgo](https://visualgo.net/) - 数据结构可视化
- [Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/)

---

## 🔗 学习路径

### 推荐顺序
1. **数组与链表** → 基础，理解连续vs链接存储
2. **栈与队列** → 简单但重要的抽象
3. **哈希表** → 实际应用最广泛
4. **树** → 理解递归和层级关系
5. **图** → 最复杂，但建模能力最强

### 进阶主题
- 跳表 (Skip List)
- B树/B+树 (数据库索引)
- 布隆过滤器 (Bloom Filter)
- 并查集 (Union-Find)

---

## 🔗 相关概念

- [算法基础](../algorithms/) - 数据结构是算法的基础
- [编程范式](../programming-concepts/programming-paradigms.md) - 不同范式实现数据结构
- [内存管理](../programming-concepts/memory-management.md) - 理解数据在内存中的布局
- [复杂度分析](../algorithms/complexity-analysis.md) - 评估数据结构性能

---

## 📚 推荐资源

**书籍**：
- 《算法（第4版）》
- 《数据结构与算法分析》
- 《算法导论》

**在线课程**：
- Coursera: 数据结构与算法
- LeetCode: 刷题练习

**实践**：
- 实现常用数据结构
- 解决LeetCode题目
- 分析开源项目中的数据结构使用

---

**记住**：
1. 没有最好的数据结构，只有最适合的
2. 理解权衡（时间 vs 空间）
3. 从简单到复杂，循序渐进
4. 多动手实现，多思考应用场景
5. 数据结构 + 算法 = 编程核心能力

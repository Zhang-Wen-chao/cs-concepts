# The basics
好的，我们用简单的话来解释一下 NumPy 的核心概念。

NumPy 最主要的东西是一个叫做 **`ndarray`** 的多维数组。你可以把它想象成一个表格，里面装着很多元素（通常是数字），并且所有元素的类型都必须一样。

1.  **轴 (Axes)**
    在 NumPy 里，“维度”被称为“轴”。
    *   一维数组，比如 `[1, 2, 1]`，就只有 1 个轴，长度是 3。
    *   二维数组，比如 `[[1., 0., 0.], [0., 1., 2.]]`，就有 2 个轴。第一个轴（可以看作“行”）的长度是 2，第二个轴（可以看作“列”）的长度是 3。

2.  **`ndarray` 的重要属性**
    `ndarray` 对象有一些重要的属性，可以帮助我们了解这个数组：

    *   **`ndarray.ndim`**: 数组的轴（维度）的数量。比如，一维数组的 `ndim` 是 1，二维数组是 2。
    *   **`ndarray.shape`**: 数组的形状。它是一个元组（tuple），表示数组在每个维度上的大小。例如，一个 2 行 3 列的二维数组，它的 `shape` 就是 `(2, 3)`。
    *   **`ndarray.size`**: 数组中所有元素加起来的总个数。它等于 `shape` 元组中所有数字的乘积。对于 `(2, 3)` 形状的数组，`size` 就是 2 * 3 = 6。
    *   **`ndarray.dtype`**: 数组里元素的数据类型。比如 `int32`（32位整数）或者 `float64`（64位浮点数）。
    *   **`ndarray.itemsize`**: 数组里每个元素占用的内存大小（单位是字节）。例如，`float64` 类型的元素，`itemsize` 就是 8 (因为 64/8 = 8)。
    *   **`ndarray.data`**: 存放数组实际元素的内存地址。一般情况下，我们不需要直接访问它，而是通过索引（比如 `arr[0]`）来操作数组元素。
# Basic operations
好的，我们来简单解释一下 NumPy 数组的基本运算。

### 基本运算 (Basic operations)

1.  **逐元素运算**
    数组的算术运算符（如 `+`, `-`, `*`, `/`）是**逐个元素**进行运算的。运算后会创建一个新数组来存放结果。

    ```python
    a = np.array([20, 30, 40, 50])
    b = np.arange(4)  # b 是 [0, 1, 2, 3]

    # 逐元素相减
    c = a - b  # -> array([20, 29, 38, 47])

    # 逐元素平方
    b**2  # -> array([0, 1, 4, 9])

    # 比较运算也是逐元素的
    a < 35  # -> array([ True,  True, False, False])
    ```

2.  **乘法：`*` vs `@`**
    这一点和很多矩阵语言不同：
    *   `*` 运算符在 NumPy 中执行的是**逐元素乘法**。
    *   `@` 运算符（在 Python 3.5+ 中可用）或者 `.dot()` 方法执行的是真正的**矩阵乘法**。

    ```python
    A = np.array([[1, 1], [0, 1]])
    B = np.array([[2, 0], [3, 4]])

    # 逐元素乘法
    A * B  # -> array([[2, 0], [0, 4]])

    # 矩阵乘法
    A @ B  # -> array([[5, 4], [3, 4]])
    A.dot(B) # 效果同上
    ```

3.  **原地修改 (In-place operations)**
    像 `+=` 和 `*=` 这样的运算符会**直接修改原数组**，而不是创建一个新数组。

    ```python
    a = np.ones((2, 3), dtype=int) # a 是 [[1, 1, 1], [1, 1, 1]]
    a *= 3 # a 现在变成了 [[3, 3, 3], [3, 3, 3]]
    ```
    **注意**：在原地修改时，类型不会自动转换。如果你试图将一个浮点数数组加到一个整数数组上，就会报错。

4.  **类型提升 (Upcasting)**
    当不同类型的数组进行运算时，结果数组的类型会自动“提升”到更精确或更通用的类型。
    *   `整数` + `浮点数` -> `浮点数`
    *   `浮点数` + `复数` -> `复数`

    ```python
    a = np.ones(3, dtype=np.int32) # 整数数组
    b = np.linspace(0, np.pi, 3)  # 浮点数数组

    c = a + b # c 的类型会自动提升为 float64
    ```

5.  **聚合运算**
    很多操作（如求和、求最大/最小值）是 `ndarray` 对象自带的方法。

    *   `a.sum()`: 计算数组所有元素的和。
    *   `a.min()`: 计算数组的最小值。
    *   `a.max()`: 计算数组的最大值。

    默认情况下，这些运算会把整个数组看作一个长长的数字列表来计算。

6.  **指定轴 (axis) 运算**
    你可以通过 `axis` 参数，让聚合运算沿着指定的轴进行。
    *   `axis=0`: 沿着**列**的方向进行运算。
    *   `axis=1`: 沿着**行**的方向进行运算。

    ```python
    b = np.arange(12).reshape(3, 4)
    # b 是:
    # [[ 0,  1,  2,  3],
    #  [ 4,  5,  6,  7],
    #  [ 8,  9, 10, 11]]

    # 按列求和
    b.sum(axis=0)  # -> array([12, 15, 18, 21])

    # 按行求最小值
    b.min(axis=1)  # -> array([0, 4, 8])

    # 按行计算累计和
    b.cumsum(axis=1)
    # -> array([[ 0,  1,  3,  6],
    #           [ 4,  9, 15, 22],
    #           [ 8, 17, 27, 38]])
    ```
### 通用函数 (Universal functions)
NumPy 提供了很多我们熟悉的数学函数，比如 sin (正弦), cos (余弦), exp (指数函数) 等。在 NumPy 中，这些函数被称为“通用函数”（universal functions），简称 ufunc。  这些函数的主要特点是它们在数组上进行逐元素 (element-wise) 操作，并返回一个新数组作为结果。这意味着函数会分别作用于输入数组中的每一个元素。
### Indexing, slicing and iterating
可以理解为和Python一样。
# Shape manipulation
好的，我们来简单解释一下如何操作 NumPy 数组的形状。

### 改变数组的形状 (Shape manipulation)

#### 1. 改变形状 (Changing the shape)

你可以用多种方式改变一个数组的形状（即维度）。

*   `a.shape`: 查看数组的形状。
*   `a.ravel()`: 将多维数组**“展平”**成一个一维数组。
*   `a.reshape(行, 列)`: 在不改变数据的情况下，重新组织成新的形状。
*   `a.T`: 将数组**转置**（行和列互换）。

**重要提示**：`ravel()`, `reshape()`, 和 `T` 这三个操作都会返回一个**新的**修改后数组（通常是原始数组的一个“视图”），而**不会改变原始数组 `a` 本身**。

```python
# a 是一个 3x4 的数组
a = np.floor(10 * rg.random((3, 4)))

a.ravel()       # 返回一个 1x12 的数组
a.reshape(6, 2) # 返回一个 6x2 的数组
a.T             # 返回一个 4x3 的数组
```

*   **`reshape` vs `resize`**:
    *   `reshape` 返回一个新数组，原数组不变。
    *   `ndarray.resize` 会**直接修改原数组**，没有返回值。

    ```python
    a.resize((2, 6)) # a 本身变成了 2x6 的形状
    ```

*   **自动计算维度**: 在 `reshape` 中，你可以将其中一个维度设为 `-1`，NumPy 会自动计算出该维度的大小。
    ```python
    a.reshape(3, -1) # NumPy 会自动计算出列数为 4
    ```

#### 2. 堆叠不同的数组 (Stacking together different arrays)

你可以将多个数组堆叠起来形成一个新数组。

*   `np.vstack((a, b))`: **垂直堆叠** (Vertical Stack)，像叠盘子一样，将数组 `b` 放在 `a` 的下面。
*   `np.hstack((a, b))`: **水平堆叠** (Horizontal Stack)，像书并排放在书架上，将数组 `b` 放在 `a` 的右边。
*   `np.column_stack((a, b))`: 将一维数组作为列堆叠成一个二维数组。对于二维数组，它的效果和 `hstack` 类似。

```python
a = np.array([[9., 7.], [5., 2.]])
b = np.array([[1., 9.], [5., 1.]])

np.vstack((a, b))
# -> array([[9., 7.],
#           [5., 2.],
#           [1., 9.],
#           [5., 1.]])

np.hstack((a, b))
# -> array([[9., 7., 1., 9.],
#           [5., 2., 5., 1.]])
```

#### 3. 将一个数组分割成几个小数组 (Splitting one array into several smaller ones)

你可以将一个大数组分割成几个小数组。

*   `np.hsplit(a, 3)`: **水平分割** (Horizontal Split)。将数组 `a` 水平地切成 3 个等宽的小数组。
*   `np.hsplit(a, (3, 4))`: 在指定的列（第3列和第4列）之后进行水平分割。
*   `np.vsplit(a, ...)`: **垂直分割** (Vertical Split)，沿着垂直方向（行）进行分割。

```python
a = np.floor(10 * rg.random((2, 12))) # a 是一个 2x12 的数组

# 水平切成 3 个等大的数组
np.hsplit(a, 3)
# -> 返回一个列表，包含三个 2x4 的数组

# 在第3列和第4列后进行切割
np.hsplit(a, (3, 4))
# -> 返回一个列表，包含一个 2x3, 一个 2x1, 和一个 2x8 的数组
```
# Copies and views
好的，我们来简单解释一下 NumPy 中关于副本和视图的概念，这对于理解 NumPy 如何管理内存非常重要。

### 副本和视图 (Copies and views)

在操作 NumPy 数组时，有时会创建一个全新的数组副本，有时则不会。这主要分为三种情况：

#### 1. 完全不复制 (No copy at all)

*   **简单赋值**: 当你执行 `b = a` 时，你并没有创建一个新的数组。`a` 和 `b` 只是指向内存中同一个数组对象的两个不同名字而已。修改 `b` 就会修改 `a`，反之亦然。

    ```python
    a = np.array([[0, 1], [4, 5]])
    b = a  # b 和 a 是同一个东西
    b is a # -> True
    ```

*   **函数传参**: 将数组作为参数传递给函数时，也是传递的引用，不会创建副本。

#### 2. 视图或浅拷贝 (View or shallow copy)

这是 NumPy 一个非常重要的特性。

*   **什么是视图？**: 一个“视图”是一个新的数组对象，但它和原始数组**共享同一块数据内存**。它只是看待这块数据的不同“视角”。
*   **如何创建视图？**:
    *   使用 `.view()` 方法。
    *   **对数组进行切片 (Slicing)** 操作返回的就是一个视图。

*   **关键特性**: 修改视图会**直接影响**原始数组的数据，因为它们共享数据。

    ```python
    a = np.array([[0, 1, 2], [10, 11, 12]])

    # 创建一个视图
    c = a.view()
    c is a # -> False (c 和 a 是不同的对象)
    c.base is a # -> True (但 c 的数据基础是 a)

    # 对数组进行切片，s 是 a 的一个视图
    s = a[:, 1:3] # 取出所有行的第2列到第3列

    # 修改切片 s
    s[:] = 99

    # 原始数组 a 也被改变了！
    # a -> array([[ 0, 99, 99],
    #             [10, 99, 99]])
    ```
    **注意**：这是 NumPy 和 Python 列表的一个核心区别。列表的切片会创建一个全新的副本。

#### 3. 深拷贝 (Deep copy)

*   **什么是深拷贝？**: 使用 `.copy()` 方法会创建一个**全新的数组**，并附带一份**全新的数据副本**。
*   **关键特性**: 新数组和原始数组完全独立。修改一个不会影响另一个。

    ```python
    a = np.array([[0, 10], [12, 7]])
    d = a.copy() # 创建一个完整的副本

    d is a # -> False
    d.base is a # -> False (d 不与 a 共享任何东西)

    # 修改副本 d
    d[0, 0] = 9999

    # 原始数组 a 保持不变
    # a -> array([[ 0, 10],
    #             [12,  7]])
    ```

#### 总结与建议

*   **赋值 (`=`)**: 只是换个名字，还是同一个东西。
*   **视图 (`view()` 或切片)**：不同的对象，但共享数据。修改会互相影响。这样做是为了高效，避免不必要的数据复制。
*   **副本 (`copy()`)**: 完全独立的新对象和新数据。

**什么时候应该用 `.copy()`？**
当你从一个非常大的数组中切片出一小部分，并且不再需要那个大数组时，最好使用 `.copy()`。这样，原始的大数组占用的内存就可以被系统回收。否则，即使你删除了大数组的变量名，只要那个小小的视图还存在，整个大数组的数据就必须一直保留在内存中。
# Functions and methods overview
好的，我们来简单解释一下 NumPy 中一些常用函数和方法的概览。

### 函数和方法概览 (Functions and methods overview)

这里将一些有用的 NumPy 函数按照功能进行了分类。

#### 1. 数组创建 (Array Creation)

这些函数用于创建新的 NumPy 数组。

*   `arange`: 类似于 Python 的 `range`，但返回一个 NumPy 数组。
*   `array`: 从 Python 列表或元组创建数组。
*   `zeros`, `ones`: 创建一个填满 0 或 1 的数组。
*   `empty`: 创建一个数组，但其内容是未初始化的（随机值）。
*   `linspace`: 创建一个包含指定范围内等间隔数值的数组。
*   `copy`: 创建一个数组的深拷贝。

#### 2. 转换 (Conversions)

这些函数用于转换数组的数据类型或维度。

*   `ndarray.astype`: 将数组转换为指定的数据类型（例如，从浮点数 `float` 转为整数 `int`）。
*   `atleast_1d`, `atleast_2d`: 确保输入至少是一维或二维数组。

#### 3. 操作 (Manipulations)

这些函数用于改变数组的形状或组合/拆分数组。

*   `reshape`: 改变数组的形状（例如，从 1x12 变为 3x4）。
*   `ravel`: 将多维数组“展平”为一维数组。
*   `transpose`, `swapaxes`: 转置数组（交换维度）。
*   `hstack`, `vstack`, `concatenate`: 将多个数组水平、垂直或沿指定轴连接起来。
*   `hsplit`, `vsplit`, `array_split`: 将一个数组水平、垂直或沿指定轴拆分成多个小数组。

#### 4. 查询 (Questions)

这些函数用于检查数组的内容。

*   `nonzero`: 找出数组中非零元素的索引。
*   `where`: 根据条件从两个数组中选择元素，生成一个新数组。
*   `all`, `any`: 检查数组中的元素是否全部为 `True` 或至少有一个为 `True`。

#### 5. 排序 (Ordering)

这些函数用于排序和查找最值。

*   `sort`: 对数组进行排序。
*   `max`, `min`: 找出数组中的最大值和最小值。
*   `argmax`, `argmin`: 找出数组中最大值和最小值的**索引**。

#### 6. 运算 (Operations)

这些是作用于整个数组的数学运算。

*   `sum`: 计算数组所有元素的和。
*   `prod`: 计算数组所有元素的乘积。
*   `cumsum`, `cumprod`: 计算元素的累加和或累乘积。
*   `real`, `imag`: 分别获取复数数组的实部和虚部。

#### 7. 基本统计 (Basic Statistics)

这些函数用于执行基本的统计计算。

*   `mean`: 计算平均值。
*   `std`: 计算标准差。
*   `var`: 计算方差。

#### 8. 基本线性代数 (Basic Linear Algebra)

这些函数用于执行线性代数运算。

*   `dot`: 计算两个数组的点积（对于矩阵，就是矩阵乘法）。
*   `cross`: 计算两个向量的叉积。
*   `outer`: 计算两个向量的外积。
*   `linalg.svd`: 进行奇异值分解 (SVD)。
# Broadcasting rules
好的，我们来简单解释一下 NumPy 中非常强大的“广播”机制。

### 广播规则 (Broadcasting rules)

“广播” (Broadcasting) 是一套规则，它允许 NumPy 在处理**形状不完全相同**的数组时，能够智能地执行算术运算（如加、减、乘、除）。这避免了为匹配形状而手动创建数据副本，非常高效。

广播遵循以下两个核心规则：

**规则 1：对齐维度**

如果参与运算的两个数组的维度数量不同，NumPy 会在**维度较少**的那个数组的形状**前面**补 1，直到它们的维度数量相同。

*   例如：一个形状为 `(3, 4)` 的二维数组和一个形状为 `(4,)` 的一维数组相加。
*   根据规则1，一维数组的形状会变为 `(1, 4)`，以匹配二维数组的维度数量。

**规则 2：扩展维度**

在两个数组的维度对齐后，NumPy 会逐个比较它们的每个维度的大小。在某个维度上，如果两个数组满足以下任一条件，则它们是“兼容的”：
1.  它们在该维度上的大小相等。
2.  其中一个在该维度上的大小为 1。

如果兼容，NumPy 就会沿着大小为 1 的那个维度进行“拉伸”或“复制”，使其大小与另一个数组在该维度上的大小相匹配。

*   继续上面的例子，现在我们比较形状 `(3, 4)` 和 `(1, 4)`：
    *   **第一个维度**：大小分别为 3 和 1。兼容。NumPy 会将形状为 `(1, 4)` 的数组沿着这个维度“拉伸”3次，使其表现得像一个形状为 `(3, 4)` 的数组。
    *   **第二个维度**：大小都为 4。兼容。

**最终条件**

在应用了以上规则后，如果两个数组在所有维度上都是兼容的，运算就可以执行。否则，NumPy 会报错。

#### 简单总结

你可以把广播想象成：当一个“小”数组和一个“大”数组运算时，NumPy 会尝试通过“复制”和“拉伸”那个“小”数组，让它变得和“大”数组一样大，从而可以进行逐元素的运算。这个过程是在内部虚拟发生的，并不会真的消耗内存去创建复制品，所以效率很高。
# Advanced indexing and index tricks
好的，我们来简单解释一下 NumPy 中更高级的索引技巧。

### 高级索引和索引技巧 (Advanced indexing and index tricks)

除了之前介绍的整数和切片，NumPy 还支持两种更强大的索引方式：使用**整数数组**和**布尔数组**进行索引。

#### 1. 使用索引数组进行索引 (Indexing with arrays of indices)

你可以用一个数组来指定需要抽取的元素的索引。

*   **一维情况**:
    ```python
    a = np.arange(12)**2  # -> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121]
    i = np.array([1, 1, 3, 8, 5]) # 这是一个索引数组

    # 从 a 中挑选出索引为 1, 1, 3, 8, 5 的元素
    a[i] # -> array([ 1,  1,  9, 64, 25])
    ```
    返回的数组形状和索引数组 `i` 的形状相同。

*   **多维情况**:
    你可以为多个维度同时提供索引数组，但这些索引数组的形状必须相同。

    ```python
    a = np.arange(12).reshape(3, 4)
    # a -> array([[ 0,  1,  2,  3],
    #             [ 4,  5,  6,  7],
    #             [ 8,  9, 10, 11]])

    # i 是行的索引，j 是列的索引
    i = np.array([[0, 1], [1, 2]])
    j = np.array([[2, 1], [3, 3]])

    # a[i, j] 会取出 (i[0,0], j[0,0]), (i[0,1], j[0,1]), ... 这些坐标上的元素
    # 即 (0,2), (1,1), (1,3), (2,3)
    a[i, j] # -> array([[ 2,  5],
            #          [ 7, 11]])
    ```

*   **赋值**: 你也可以用这种索引方式来赋值。
    ```python
    a = np.arange(5) # -> [0, 1, 2, 3, 4]
    a[[1, 3, 4]] = 0 # 将索引为 1, 3, 4 的元素赋值为 0
    a # -> array([0, 0, 2, 0, 0])
    ```
    **注意**: 如果索引有重复，比如 `a[[0, 0, 2]] += 1`，那么第 0 个元素只会被增加一次，而不是两次。

#### 2. 使用布尔数组进行索引 (Indexing with boolean arrays)

这种方式不是提供索引列表，而是提供一个“遮罩”(mask)，明确指出哪些元素是我们想要的 (`True`)，哪些不是 (`False`)。

*   **与原数组形状相同的布尔数组**:
    ```python
    a = np.arange(12).reshape(3, 4)
    b = a > 4 # b 是一个布尔数组，形状和 a 一样
    # b -> array([[False, False, False, False],
    #             [False,  True,  True,  True],
    #             [ True,  True,  True,  True]])

    # a[b] 会选出 a 中所有对应 b 中为 True 的元素
    a[b] # -> array([ 5,  6,  7,  8,  9, 10, 11])
    # 注意：结果是一个一维数组
    ```
    这个特性在赋值时非常有用：
    ```python
    a[b] = 0 # 将 a 中所有大于 4 的元素都变成 0
    ```

*   **使用一维布尔数组选择切片**:
    你可以用一维布尔数组来选择行或列。
    ```python
    a = np.arange(12).reshape(3, 4)
    b1 = np.array([False, True, True]) # 长度为3，对应3行
    b2 = np.array([True, False, True, False]) # 长度为4，对应4列

    a[b1, :] # 选择 b1 中为 True 的行 (第1行和第2行)
    # -> array([[ 4,  5,  6,  7],
    #           [ 8,  9, 10, 11]])

    a[:, b2] # 选择 b2 中为 True 的列 (第0列和第2列)
    # -> array([[ 0,  2],
    #           [ 4,  6],
    #           [ 8, 10]])
    ```

#### 3. `ix_()` 函数

`ix_` 是一个辅助函数，当你需要对多个向量的所有元素组合进行计算时非常有用。

*   **场景**: 假设有向量 `a`, `b`, `c`，你想计算所有 `a_i + b_j * c_k` 的组合结果。
*   **作用**: `np.ix_(a, b, c)` 会创建三个新的数组，它们的维度经过特殊设计，以便后续可以利用**广播**机制进行计算。
*   **好处**: 这样做可以避免手动创建一个巨大的、包含所有组合的中间数组，从而节省内存并利用 NumPy 的广播高效地完成计算。
# Tricks and tips
好的，我们来简单解释一下 NumPy 的一些实用技巧。

### 技巧和提示 (Tricks and tips)

这里是一些简短而有用的小技巧。

#### 1. “自动”重塑形状 (Automatic reshaping)

当你使用 `reshape` 函数改变数组维度时，可以省略其中一个维度的大小，NumPy 会自动为你计算出来。你只需将那个维度的大小设为 `-1`。

```python
a = np.arange(30) # a 是一个包含30个元素的一维数组

# 将 a 重塑为一个三维数组，形状为 (2, ?, 3)
# NumPy 会自动计算出 ? 必须是 5 (因为 2 * 5 * 3 = 30)
b = a.reshape((2, -1, 3))

b.shape # -> (2, 5, 3)
```
`-1` 的意思是“无论需要多大，就设为多大”。

#### 2. 向量堆叠 (Vector stacking)

如何从一系列等长的行向量构建一个二维数组？在 NumPy 中，这可以通过 `vstack` (垂直堆叠) 或 `hstack` (水平堆叠) 等函数轻松实现。

*   `np.vstack([x, y])`: **垂直堆叠**，将向量 `x` 和 `y` 作为行堆叠起来，形成一个二维数组。
*   `np.hstack([x, y])`: **水平堆叠**，将向量 `x` 和 `y` 首尾连接，形成一个更长的一维数组。

```python
x = np.arange(0, 10, 2) # -> [0, 2, 4, 6, 8]
y = np.arange(5)        # -> [0, 1, 2, 3, 4]

# 垂直堆叠
m = np.vstack([x, y])
# m -> array([[0, 2, 4, 6, 8],
#             [0, 1, 2, 3, 4]])

# 水平堆叠
xy = np.hstack([x, y])
# xy -> array([0, 2, 4, 6, 8, 0, 1, 2, 3, 4])
```

#### 3. 直方图 (Histograms)

NumPy 和 Matplotlib 都有计算直方图的函数，但它们的作用不同，需要注意区分。

*   `numpy.histogram()`: 这个函数**只负责计算**。它会返回两样东西：一个包含每个区间计数的数组，和一个包含区间边界的数组。它**不会绘制**任何图形。
*   `matplotlib.pyplot.hist()`: 这个函数**既计算又绘制**。它会直接根据你的数据生成并显示一个直方图。

简单来说：
*   如果只想得到直方图的统计数据，用 `numpy.histogram`。
*   如果想直接画出直方图，用 `matplotlib.pyplot.hist`。
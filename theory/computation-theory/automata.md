# 自动机理论 (Automata Theory)

> 抽象的计算模型：用数学方式描述"计算"

## 🎯 核心思想

自动机是一种抽象的计算设备，就像一台极简的"计算机"。它读取输入，根据规则改变状态，最终判断是否接受这个输入。

**一句话理解：**
- 自动机就像一个**状态机器**，根据输入在不同状态间跳转，最终判断输入是否合法

**实际例子：**
```
自动售货机：
状态：等待投币 → 选择商品 → 出货 → 找零
输入：硬币、按钮
输出：商品、找零

交通信号灯：
状态：红灯 → 绿灯 → 黄灯 → 红灯
输入：时间/传感器
输出：灯的颜色
```

## 📖 有限状态自动机 (Finite Automaton)

### 1. 确定性有限自动机 (DFA)

#### 定义
```
DFA = (Q, Σ, δ, q₀, F)

Q：状态集合
Σ：输入符号集合（字母表）
δ：状态转移函数 Q × Σ → Q
q₀：初始状态
F：接受状态集合
```

#### 直观理解

**例子：识别以"01"结尾的二进制串**

```
输入：10101  → 接受 ✓
输入：10100  → 拒绝 ✗
输入：01     → 接受 ✓

状态图：
       0           1
  → (q₀) ─────→ (q₁) ─────→ ((q₂))
     ↓ 1         ↓ 0          ↓ 0,1
     └───────────┴────────────┘

• → 表示初始状态
• (( )) 表示接受状态
```

**运行过程：**
```
输入串：101
初始：q₀

读入 '1'：q₀ → q₁  (因为 δ(q₀, 1) = q₁)
读入 '0'：q₁ → q₁  (因为 δ(q₁, 0) = q₁)
读入 '1'：q₁ → q₂  (因为 δ(q₁, 1) = q₂)

最终状态：q₂（接受状态）→ 接受 ✓
```

**代码实现：**
```python
class DFA:
    def __init__(self):
        self.state = 'q0'  # 初始状态

    def transition(self, char):
        # 状态转移函数
        if self.state == 'q0':
            self.state = 'q1' if char == '0' else 'q0'
        elif self.state == 'q1':
            self.state = 'q2' if char == '1' else 'q1'
        elif self.state == 'q2':
            self.state = 'q1' if char == '0' else 'q0'

    def accept(self, string):
        self.state = 'q0'  # 重置
        for char in string:
            self.transition(char)
        return self.state == 'q2'  # 检查是否在接受状态

# 测试
dfa = DFA()
print(dfa.accept("101"))   # True
print(dfa.accept("100"))   # False
print(dfa.accept("01"))    # True
```

#### 更多例子

**例1：识别偶数个0的二进制串**

```
     0          0
  → (q₀) ←→ (q₁)
    ↓ 1      ↓ 1
    └────────┘

q₀：偶数个0（接受状态）
q₁：奇数个0

δ(q₀, 0) = q₁
δ(q₀, 1) = q₀
δ(q₁, 0) = q₀
δ(q₁, 1) = q₁
```

**例2：识别包含子串"abc"的字符串**

```
            a          b          c
  → (q₀) ─────→ (q₁) ─────→ (q₂) ─────→ ((q₃))
     ↓ b,c       ↓ a,c       ↓ a,b        ↓ a,b,c
     └───────────┴───────────┴────────────┘

q₃是接受状态，一旦到达就停留
```

### 2. 非确定性有限自动机 (NFA)

#### 为什么需要NFA？

DFA的限制：
- 每个状态对每个输入，只能有一个转移
- 设计复杂模式时，状态数可能爆炸

NFA的特点：
- 可以有多个可能的转移
- 可以有ε转移（不读输入就跳转）
- 更容易设计，状态更少

#### NFA vs DFA

**识别包含"01"或"10"的串**

**DFA需要4个状态：**
```
复杂的状态图...
```

**NFA只需要5个状态：**
```
              0        1
    → (q₀) ─────→ (q₁) ─────→ ((q₂))  接受"01"
        ↓
        │ 1        0
        └────→ (q₃) ─────→ ((q₄))      接受"10"
```

从q₀开始，可以同时探索两条路径！

#### ε-转移（空转移）

```
不读任何输入就可以跳转

       ε           a
  → (q₀) ─────→ (q₁) ─────→ ((q₂))

从q₀可以"免费"跳到q₁
```

**实际例子：正则表达式 (a|b)c**

```
              a
       ┌──────────┐
       │          ↓
  → (q₀)       (q₂) ───c───→ ((q₃))
       │ ε        ↑
       └─→ (q₁) ─┘
            b

q₀通过ε转移分支到两条路径
```

#### NFA的执行：非确定性

```
输入：01
初始：{q₀}

读入'0'：{q₀, q₁, q₃}  (q₀可以去多个地方)
读入'1'：{q₀, q₂, q₄}  (从多个状态继续转移)

只要有一条路径到达接受状态 → 接受 ✓
```

**理解方式：**
- DFA：只有一条确定的路径
- NFA：同时探索所有可能的路径（想象多个"平行宇宙"）
- 只要有一条路径成功，就接受输入

### 3. DFA vs NFA：等价性

**重要定理：NFA和DFA能力相同**

```
任何NFA都可以转换为等价的DFA

证明思想：
• DFA的状态 = NFA可能处于的状态集合
• DFA用状态集合来模拟NFA的多条路径

例子：NFA有3个状态 → DFA最多有2³=8个状态
```

**转换例子：**

**NFA：**
```
         a          a
    → (q₀) ←→ (q₁)
         ↓ b      ↓ b
        ((q₂))←───┘

q₂是接受状态
```

**等价的DFA：**
```
状态命名：用集合表示
{q₀}：初始状态
{q₀,q₁}：同时在q₀和q₁
{q₂}：接受状态

         a              a              b
    → {q₀} ──→ {q₀,q₁} ──→ {q₀,q₁,q₂} ──→ ...
       ↓ b
      {q₂}

任何包含q₂的状态都是接受状态
```

**为什么使用NFA？**
- 设计更直观
- 状态更少
- 正则表达式直接对应NFA
- 实际使用时再转为DFA执行

## 📖 下推自动机 (Pushdown Automaton, PDA)

### 1. 为什么需要PDA？

**DFA/NFA的限制：没有"记忆"**

```
DFA无法识别：
• {0ⁿ1ⁿ | n ≥ 0}  即"相同数量的0和1"
  如：01, 0011, 000111 ✓
      0, 011, 00111 ✗

原因：需要"记住"看到了多少个0，DFA只有有限个状态，无法计数
```

**PDA的能力：有一个栈（无限容量）**

```
PDA = DFA + Stack

可以：
• 压栈（push）
• 出栈（pop）
• 看栈顶（peek）
```

### 2. PDA如何工作

**识别 {0ⁿ1ⁿ}**

```
策略：
1. 每读一个0，压栈一个符号
2. 每读一个1，弹栈一个符号
3. 读完后，栈空 → 接受

状态图：
              0/ε→A          1/A→ε
    → (q₀) ─────────→ (q₁) ─────────→ (q₂)
       ↑                ↓               ↓
       └────────────────┴───────────────┘
            栈空时接受

符号说明：
• 0/ε→A：读入0，不弹栈，压入A
• 1/A→ε：读入1，弹出A，不压栈
```

**运行示例：输入 0011**

```
步骤    输入    状态    栈
1      0011    q₀      []
2      011     q₁      [A]        读0，压A
3      11      q₁      [A,A]      读0，压A
4      1       q₁      [A]        读1，弹A
5      ε       q₂      []         读1，弹A，栈空

结果：接受 ✓
```

**运行示例：输入 001**

```
步骤    输入    状态    栈
1      001     q₀      []
2      01      q₁      [A]
3      1       q₁      [A,A]
4      ε       q₁      [A]        栈非空！

结果：拒绝 ✗
```

### 3. PDA vs 上下文无关文法

**重要：PDA能力 = 上下文无关文法**

```
上下文无关文法（CFG）例子：
S → 0S1 | ε

生成语言：{0ⁿ1ⁿ}

PDA ←→ CFG 一一对应
```

**实际应用：编程语言的括号匹配**

```
识别：({[]})  ✓
拒绝：({[}])  ✗

策略：
• 遇到左括号 → 压栈
• 遇到右括号 → 弹栈，检查匹配
• 最后栈空 → 接受

栈的变化：
输入 ( { [ ] } )
栈   (
     ( {
     ( { [
     ( {         弹出[，匹配
     (           弹出{，匹配
     空          弹出(，匹配 → 接受✓
```

## 📖 图灵机 (Turing Machine)

### 1. 为什么需要图灵机？

**PDA的限制：只能用栈**

```
PDA无法识别：
• {0ⁿ1ⁿ0ⁿ}
• {ww | w是任意串}  （回文的变体）

原因：栈只能后进先出，无法随机访问
```

**图灵机的能力：无限长的纸带**

```
图灵机 = 自动机 + 无限纸带 + 读写头

可以：
• 在纸带上读写
• 左右移动读写头
• 模拟任何计算机程序
```

### 2. 图灵机的定义

```
TM = (Q, Σ, Γ, δ, q₀, q_accept, q_reject)

Q：状态集合
Σ：输入字母表
Γ：纸带字母表（Σ ⊂ Γ）
δ：转移函数 Q × Γ → Q × Γ × {L, R}
    (读到什么，写什么，左移还是右移)
q₀：初始状态
q_accept：接受状态
q_reject：拒绝状态
```

### 3. 图灵机如何工作

**例子：识别 {0ⁿ1ⁿ}**

```
策略：
1. 找到最左边的0，标记为X
2. 向右找到第一个1，标记为Y
3. 回到开头，重复
4. 如果0和1都标记完 → 接受

纸带：
初始：[0][0][1][1][⊔]
步骤1：[X][0][1][1][⊔]  标记第一个0
步骤2：[X][0][Y][1][⊔]  找到第一个1
步骤3：[X][X][Y][1][⊔]  回到开头，标记第二个0
步骤4：[X][X][Y][Y][⊔]  标记第二个1
步骤5：检查是否全部标记完 → 接受✓
```

**状态转移表：**

```
状态    读    写    移动    新状态
q₀      0     X     R      q₁     (标记0)
q₁      0     0     R      q₁     (跳过0)
q₁      Y     Y     R      q₁     (跳过已标记的1)
q₁      1     Y     L      q₂     (标记1)
q₂      0     0     L      q₂     (返回)
q₂      X     X     R      q₀     (回到开头)
q₀      Y     Y     R      q₃     (检查阶段)
q₃      Y     Y     R      q₃     (全是Y)
q₃      ⊔     ⊔     R      accept (成功)
```

### 4. 图灵机的计算能力

**Church-Turing论题：**
```
任何"可计算"的东西，图灵机都能计算

等价的计算模型：
• 图灵机
• Lambda演算
• 递归函数
• 现代编程语言

→ 图灵机 = 通用计算模型
```

**图灵机可以：**
```
✓ 加法、乘法、任何算术
✓ 排序、搜索
✓ 模拟任何程序
✓ 模拟另一个图灵机（通用图灵机）
```

**图灵机不能：**
```
✗ 停机问题（判断程序是否会停止）
✗ 判断两个程序是否等价
✗ 完美的病毒检测

→ 存在不可计算的问题
```

## 🔧 自动机层次

```
能力递增：
DFA/NFA ⊂ PDA ⊂ 线性有界自动机 ⊂ 图灵机

对应语言：
正则语言 ⊂ 上下文无关 ⊂ 上下文相关 ⊂ 递归可枚举

             自动机              语言类型
─────────────────────────────────────────────
最弱        DFA/NFA            正则语言
            • 没有记忆          • 正则表达式
            • 有限状态          • a*b+

            PDA                上下文无关语言
            • 有栈              • 括号匹配
            • 无限记忆          • 算术表达式

最强        图灵机             递归可枚举语言
            • 随机访问纸带      • 任何程序
            • 通用计算          • 可计算函数
```

## 💡 实际应用

### 正则表达式 → DFA/NFA
```python
import re
pattern = r'^[0-9]{3}-[0-9]{4}$'  # 电话号码
re.match(pattern, '123-4567')     # 内部使用自动机

正则引擎步骤：
1. 正则表达式 → NFA
2. NFA → DFA
3. DFA匹配字符串
```

### 编译器词法分析 → DFA
```
识别Token类型：
• 关键字：if, for, while
• 标识符：变量名
• 数字：整数、浮点数
• 运算符：+, -, *, /

每个Token用一个DFA识别
```

### 协议状态机 → DFA
```
TCP连接状态：
CLOSED → LISTEN → SYN_SENT → ESTABLISHED → ...

每个数据包驱动状态转移
```

### 解析器 → PDA
```
语法分析：
• 表达式求值
• 括号匹配
• XML/JSON解析

使用栈来处理嵌套结构
```

## 🔗 与其他概念的联系

### 与形式语言
- **DFA/NFA** ←→ 正则语言
- **PDA** ←→ 上下文无关语言
- **图灵机** ←→ 递归可枚举语言

参考：`theory/computation-theory/formal-languages.md`

### 与编译原理
- **词法分析** - 正则表达式和DFA
- **语法分析** - CFG和PDA
- **语义分析** - 类型系统

参考：`languages/language-theory/`

### 与算法
- **状态机模式** - 设计模式中的状态模式
- **动态规划** - 自动机的状态转移

参考：`software-engineering/design-patterns/`

## 📖 扩展阅读

### 进阶主题
- 双向图灵机
- 多带图灵机
- 非确定性图灵机
- 通用图灵机（可编程的图灵机）
- 量子自动机

### 未解之谜
- P vs NP问题
- 量子计算的能力

---

**掌握自动机理论，你就理解了计算的数学本质！** 🤖

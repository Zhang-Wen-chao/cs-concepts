# 形式语言 (Formal Languages)

> 用数学方式描述语法规则

## 🎯 核心思想

形式语言就是**字符串的集合**，配合**文法规则**来描述这些字符串的结构。

**一句话理解：**
- 语言 = 一堆符合某种规则的字符串
- 文法 = 生成这些字符串的规则

**实际例子：**
```
自然语言：
• 语言：所有合法的英语句子
• 文法：英语语法规则

编程语言：
• 语言：所有合法的Python程序
• 文法：Python语法规则

数学表达式：
• 语言：1+2, (3*4)+5, ...
• 文法：表达式的构造规则
```

## 📖 基本概念

### 1. 字母表和字符串

```
字母表 Σ：有限的符号集合
  Σ = {0, 1}         二进制
  Σ = {a, b, c}      简单字母表
  Σ = {if, for, +}   编程语言的符号

字符串 w：符号的有限序列
  w = 01010          长度 = 5
  w = abc            长度 = 3
  w = ε              空串，长度 = 0

Σ*：所有可能字符串的集合
  {0,1}* = {ε, 0, 1, 00, 01, 10, 11, 000, ...}

Σ+：所有非空字符串
  {0,1}+ = {0, 1, 00, 01, 10, 11, 000, ...}
```

### 2. 语言的定义

```
语言 L：字符串的集合（Σ* 的子集）

例子：
L₁ = {0ⁿ1ⁿ | n ≥ 0}          相同数量的0和1
   = {ε, 01, 0011, 000111, ...}

L₂ = {w | w包含偶数个0}      偶数个0
   = {ε, 1, 11, 00, 101, ...}

L₃ = {aⁿbⁿcⁿ | n ≥ 0}         相同数量的a, b, c
   = {ε, abc, aabbcc, ...}
```

### 3. 语言的操作

```
并集：L₁ ∪ L₂
  {0, 00} ∪ {1, 11} = {0, 00, 1, 11}

连接：L₁ · L₂ = {xy | x∈L₁, y∈L₂}
  {0, 1} · {a, b} = {0a, 0b, 1a, 1b}

Kleene闭包：L* = ε ∪ L ∪ LL ∪ LLL ∪ ...
  {ab}* = {ε, ab, abab, ababab, ...}

补集：L̄ = Σ* - L
  如果 L = {0, 1}，那么 L̄ = {ε, 00, 01, 10, 11, ...}
```

## 📖 文法 (Grammar)

### 1. 文法的定义

```
文法 G = (V, Σ, R, S)

V：变量（非终结符）集合
Σ：终结符集合
R：产生式规则集合
S：起始变量

例子：算术表达式文法
V = {E, T}              E=表达式，T=项
Σ = {+, *, (, ), id}    终结符
S = E                   起始
R = {
  E → E + T | T         表达式规则
  T → T * id | id       项规则
}
```

### 2. 推导 (Derivation)

```
从起始变量S开始，反复应用规则，生成字符串

例子：生成 id + id * id

S ⇒ E
  ⇒ E + T           应用 E → E + T
  ⇒ T + T           应用 E → T
  ⇒ id + T          应用 T → id
  ⇒ id + T * id     应用 T → T * id
  ⇒ id + id * id    应用 T → id

⇒ 表示一步推导
⇒* 表示多步推导
```

### 3. 语法分析树

```
id + id * id 的分析树：

          E
       ／ │ ＼
      E  +  T
      │    ／│＼
      T   T * id
      │   │
     id  id

• 根节点：起始变量E
• 叶节点：终结符
• 内部节点：应用的规则
```

## 📖 乔姆斯基层次 (Chomsky Hierarchy)

### 层次结构

```
类型0：递归可枚举语言 ⊇
类型1：上下文相关语言 ⊇
类型2：上下文无关语言 ⊇
类型3：正则语言

能力递减，限制递增
```

### Type 3：正则语言 (Regular Languages)

#### 定义
```
正则文法的产生式：
A → aB    （右线性）
A → a

或
A → Ba    （左线性）
A → a

• 只能有一个变量，且在最右/最左
```

#### 例子：识别 (01)*

```
文法：
S → 0A | ε
A → 1S

推导：
S ⇒ 0A ⇒ 01S ⇒ 010A ⇒ 0101S ⇒ 0101

语言：{ε, 01, 0101, 010101, ...}
```

#### 等价表达方式

```
1. 正则文法
2. 正则表达式
3. DFA/NFA

三者等价！

正则表达式：(01)*
对应文法：S → 0A | ε, A → 1S
对应DFA：
       0        1
  → (S) ──→ (A) ──→ (S)
```

#### 正则表达式

```
基本元素：
• a          匹配字符a
• ε          空串
• ∅          空集（什么都不匹配）

运算符：
• r₁r₂       连接
• r₁|r₂      选择（或）
• r*         Kleene星号（0次或多次）
• r+         正闭包（1次或多次）
• r?         可选（0次或1次）

例子：
• (0|1)*     所有二进制串
• a*b+       0个或多个a，后跟1个或多个b
• [0-9]{3}-[0-9]{4}   电话号码 xxx-xxxx
```

#### 正则语言的性质

```
封闭性（做运算后还是正则语言）：
✓ 并：L₁ ∪ L₂
✓ 连接：L₁ · L₂
✓ 星号：L*
✓ 交：L₁ ∩ L₂
✓ 补：L̄
✓ 逆：Lᴿ（字符串反转）

泵引理（Pumping Lemma）：
如果L是正则语言，那么存在p（泵长度），
对于任何 |s| ≥ p 的串 s ∈ L，
可以分解为 s = xyz，满足：
1. |xy| ≤ p
2. |y| > 0
3. xyⁱz ∈ L，对所有 i ≥ 0

用于证明某语言不是正则的
```

#### 泵引理应用：证明 {0ⁿ1ⁿ} 不是正则的

```
反证法：假设 L = {0ⁿ1ⁿ} 是正则的

取 s = 0ᵖ1ᵖ（p是泵长度）
根据泵引理，s = xyz，|xy| ≤ p, |y| > 0

因为 |xy| ≤ p，所以 xy 全是0
设 y = 0ᵏ（k > 0）

根据泵引理，xy²z 应该在 L 中
xy²z = 0ᵖ⁺ᵏ1ᵖ

但这不在 L 中！（0的数量 ≠ 1的数量）

矛盾！所以 L 不是正则的
```

### Type 2：上下文无关语言 (Context-Free Languages)

#### 定义
```
上下文无关文法（CFG）的产生式：
A → α

• 左边：单个变量
• 右边：任意串（变量和终结符的混合）

"上下文无关"：替换A时，不考虑A周围的上下文
```

#### 例子：{0ⁿ1ⁿ}

```
文法：
S → 0S1 | ε

推导 0011：
S ⇒ 0S1 ⇒ 00S11 ⇒ 0011

• 递归结构：S在中间，两边同时加0和1
• 保证数量相同
```

#### 例子：括号匹配

```
文法：
S → SS | (S) | ε

生成：
• ()
• (())
• ()()
• ((()))
• (()())

推导 (()())：
S ⇒ (S)
  ⇒ (SS)
  ⇒ ((S)S)
  ⇒ (()S)
  ⇒ (()(S))
  ⇒ (()())
```

#### 例子：算术表达式

```
文法（考虑优先级）：
E → E + T | T           加法优先级低
T → T * F | F           乘法优先级高
F → (E) | id            括号和标识符

生成：id + id * id
E ⇒ E + T
  ⇒ T + T
  ⇒ id + T
  ⇒ id + T * F
  ⇒ id + id * F
  ⇒ id + id * id

分析树自然体现优先级：
       E
      /|\
     E + T
     |  /|\
     T T * F
     | |   |
    id id  id
```

#### 二义性 (Ambiguity)

```
二义性：同一个串有多个分析树

例子：E → E + E | E * E | id
对于 id + id * id，有两种分析树：

树1：先加后乘              树2：先乘后加
    E                        E
   /|\                      /|\
  E + E                    E * E
  |  /|\                  /|\  |
 id E * E                E + E id
    |   |                |   |
   id  id               id  id

问题：语义不同！
• 树1：(id + id) * id
• 树2：id + (id * id)

解决：重写文法，引入优先级
```

#### CFG vs PDA

```
重要定理：CFG 能力 = PDA 能力

CFG                    PDA
生成语言         ←→    识别语言
产生式规则       ←→    栈操作
推导过程         ←→    状态转移

每个CFG都可以转为PDA
每个PDA都可以转为CFG
```

#### CFG的性质

```
封闭性：
✓ 并：L₁ ∪ L₂
✓ 连接：L₁ · L₂
✓ 星号：L*
✗ 交：L₁ ∩ L₂（不封闭）
✗ 补：L̄（不封闭）

泵引理（更复杂的版本）：
如果L是CFL，存在p，对任何 |s| ≥ p 的串 s ∈ L，
可以分解为 s = uvxyz，满足：
1. |vxy| ≤ p
2. |vy| > 0
3. uvⁱxyⁱz ∈ L，对所有 i ≥ 0

用于证明某语言不是CFL
```

#### 泵引理应用：证明 {aⁿbⁿcⁿ} 不是CFL

```
反证法：假设 L = {aⁿbⁿcⁿ} 是CFL

取 s = aᵖbᵖcᵖ
根据泵引理，s = uvxyz，|vxy| ≤ p, |vy| > 0

情况分析：
1. 如果 vy 只包含一种字符（如都是a）
   → uv²xy²z 会增加a的数量，但b,c不变
   → 不在 L 中

2. 如果 vy 包含两种字符（如ab）
   → uv²xy²z 会打乱a,b,c的顺序
   → 不在 L 中

所有情况都矛盾！所以 L 不是CFL
```

#### 实际应用

```
编程语言的语法：
• 变量声明
• 函数定义
• 控制结构（if, while）
• 嵌套结构

例子：Python的if语句
stmt → if expr : suite
suite → stmt+ | simple_stmt

XML/HTML解析：
document → <tag> content </tag>
content → document* | text

JSON格式：
object → { members }
members → pair (, pair)*
pair → string : value
```

### Type 1：上下文相关语言 (Context-Sensitive Languages)

#### 定义
```
上下文相关文法（CSG）的产生式：
αAβ → αγβ

• A：单个变量
• α, β：上下文（可以是空串）
• γ：非空串

"上下文相关"：替换A要考虑周围的α和β
```

#### 例子：{aⁿbⁿcⁿ}

```
文法（简化版思想）：
S → aSBC | aBC
CB → BC           交换规则（依赖上下文）
aB → ab
bB → bb
bC → bc
cC → cc

生成 aabbcc：
S ⇒ aSBC
  ⇒ aaBCBC
  ⇒ aaBBCC      (使用CB → BC)
  ⇒ aabbCC      (应用 aB→ab, bB→bb)
  ⇒ aabbcc      (应用 bC→bc, cC→cc)
```

#### 线性有界自动机 (LBA)

```
LBA = 图灵机 + 纸带长度限制

限制：
• 纸带长度 ≤ c × |输入长度|
• 不能使用无限空间

能力：CSL ←→ LBA
```

#### 实际应用

```
• 自然语言的某些特征（性别、数的一致）
• 类型检查（变量先声明后使用）
• 赋值前检查（变量初始化）

例子：
declare x;
x := 1;      ✓

y := 1;      ✗ (y未声明)

需要上下文相关规则：
"赋值前必须有声明"
```

### Type 0：递归可枚举语言 (Recursively Enumerable)

#### 定义
```
无限制文法的产生式：
α → β

• α, β：任意串（α不能是空串）
• 没有限制！
```

#### 图灵机的能力

```
递归可枚举 = 图灵机可识别的语言

包括：
• 所有可计算的语言
• 停机的程序集合
• 任何可以写程序识别的语言

不包括：
• 不停机问题的补集
• 某些不可判定问题
```

## 🔧 乔姆斯基层次总结

```
类型    文法限制               自动机        例子
─────────────────────────────────────────────────
Type 3  A → aB | a          DFA/NFA      (01)*
正则    单个变量右侧

Type 2  A → α               PDA          0ⁿ1ⁿ
上下文  左侧单个变量                      括号匹配
无关

Type 1  αAβ → αγβ           LBA          aⁿbⁿcⁿ
上下文  考虑上下文                        变量声明
相关    |α| ≤ |γ|

Type 0  α → β               TM           任何可计算
递归    无限制                            的语言
可枚举

能力递增，限制递减 ↑
```

## 💡 实际应用场景

### 编译器设计

```
阶段                    使用的理论
─────────────────────────────────────
词法分析               正则语言 + DFA
(Lexical Analysis)     • 识别关键字、标识符、数字
                       • 正则表达式 → DFA

语法分析               CFG + PDA/LR(1)
(Syntax Analysis)      • 解析语句结构
                       • 生成抽象语法树

语义分析               CSG
(Semantic Analysis)    • 类型检查
                       • 作用域规则
```

### 正则表达式引擎

```python
import re

# 电子邮件验证（正则语言）
pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
re.match(pattern, 'user@example.com')

# URL匹配
pattern = r'https?://[^\s]+'

# 背后是：
# 正则表达式 → NFA → DFA → 高效匹配
```

### 解析器生成器

```
YACC/Bison：
• 输入：CFG规则
• 输出：解析器代码

示例（计算器）：
expr: expr '+' term    { $$ = $1 + $3; }
    | term             { $$ = $1; }
    ;
term: term '*' factor  { $$ = $1 * $3; }
    | factor           { $$ = $1; }
    ;
```

### JSON解析

```
JSON是CFL：
object → { members }
array → [ elements ]
value → string | number | object | array | true | false | null

可以用PDA或递归下降解析器
```

## 🔗 与其他概念的联系

### 与自动机理论
- **正则语言** ←→ DFA/NFA
- **上下文无关语言** ←→ PDA
- **递归可枚举** ←→ 图灵机

参考：`theory/computation-theory/automata.md`

### 与编译原理
- **词法分析** - 正则表达式
- **语法分析** - CFG解析
- **语义分析** - 属性文法

参考：`languages/language-theory/`

### 与算法
- **字符串匹配** - KMP, Boyer-Moore
- **解析算法** - LL(1), LR(1)

参考：`fundamentals/algorithms/`

## 📖 扩展阅读

### 高级主题
- 属性文法（Attribute Grammar）
- LL(k)和LR(k)解析
- 二义性消除
- 语法制导翻译
- 抽象语法树（AST）

### 工具
- Lex/Flex（词法分析器生成器）
- Yacc/Bison（语法分析器生成器）
- ANTLR（现代解析器生成器）

---

**掌握形式语言，你就理解了编程语言的数学基础！** 📝

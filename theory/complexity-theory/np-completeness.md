# NP完全性 (NP-Completeness)

> 困难问题的分类：P vs NP

## 🎯 核心思想

NP完全性理论回答一个千禧年问题：**P = NP?**

**一句话理解：**
- P = 能快速解决的问题（多项式时间）
- NP = 能快速验证答案的问题
- NP完全 = NP中最难的问题

**震撼的事实：**
```
如果任何一个NP完全问题有多项式算法
→ 所有NP问题都有多项式算法
→ P = NP
→ 密码学崩溃
→ 计算机科学革命

但50年了，没人找到，也没人证明不存在
```

## 📖 复杂度类

### 1. P类（多项式时间可解）

#### 定义

```
P = 可以在多项式时间内解决的问题

多项式时间：O(nᵏ)，k是常数
例如：O(n), O(n²), O(n³), O(n¹⁰⁰)

非多项式：O(2ⁿ), O(n!), O(nⁿ)
```

#### P类问题的例子

```
排序：
• 输入：n个数
• 问题：排序这些数
• 算法：归并排序
• 复杂度：O(n log n) ∈ P

最短路径（Dijkstra）：
• 输入：图G，起点s，终点t
• 问题：找s到t的最短路径
• 算法：Dijkstra算法
• 复杂度：O(V² + E) ∈ P

素数判定：
• 输入：整数n
• 问题：n是素数吗？
• 算法：AKS素数测试
• 复杂度：O((log n)⁶) ∈ P

最大流：
• 输入：网络G，源s，汇t
• 问题：最大流是多少？
• 算法：Ford-Fulkerson
• 复杂度：O(VE²) ∈ P
```

### 2. NP类（非确定性多项式时间）

#### 定义

```
NP = 可以在多项式时间内验证答案的问题

关键：
• 不一定能快速"找到"答案
• 但能快速"验证"答案是否正确

验证：给定候选答案（证书），在多项式时间内检查其正确性
```

#### NP问题的例子

**SAT（布尔可满足性）**
```
输入：布尔公式 (x₁ ∨ x₂) ∧ (¬x₁ ∨ x₃) ∧ (¬x₂ ∨ ¬x₃)
问题：存在赋值使公式为真吗？

求解：需要尝试所有2ⁿ种赋值（指数时间）

验证：给定赋值，代入公式计算
      (True ∨ False) ∧ (False ∨ True) ∧ (False ∨ False)
      = True ∧ True ∧ False = False
      多项式时间！

→ SAT ∈ NP
```

**哈密尔顿回路**
```
输入：图G
问题：存在访问每个顶点恰好一次的回路吗？

求解：需要尝试n!种排列（阶乘时间）

验证：给定路径[1,3,5,2,4,1]
      1. 检查是否访问每个顶点恰好一次 O(n)
      2. 检查每条边是否存在 O(n)
      多项式时间！

→ 哈密尔顿回路 ∈ NP
```

**子集和**
```
输入：集合{3, 34, 4, 12, 5, 2}，目标9
问题：存在子集和为9吗？

求解：2ⁿ个子集（指数时间）

验证：给定子集{4, 5}
      4 + 5 = 9 ✓
      O(n)时间

→ 子集和 ∈ NP
```

**旅行商问题（判定版本）**
```
输入：图G，距离d
问题：存在长度≤d的回路访问所有城市吗？

求解：n!种排列

验证：给定路径，计算长度，检查≤d
      O(n)时间

→ TSP ∈ NP
```

### 3. P vs NP

#### 关系

```
显然：P ⊆ NP

为什么？
• 如果能快速解决，当然能快速验证
• 验证：直接重新计算一遍

问题：P = NP 吗？

两种可能：
1. P = NP
   • 能快速验证 = 能快速求解
   • 所有NP问题都有多项式算法
   • 革命性的发现

2. P ≠ NP
   • 存在能快速验证但不能快速求解的问题
   • 大多数人相信这个
   • 但没有证明！
```

#### 如果 P = NP 会怎样？

```
密码学崩溃：
• RSA加密基于大数分解（NP问题）
• 如果P=NP → 多项式时间破解
• 所有加密不安全

数学证明自动化：
• 定理证明是NP问题
• 如果P=NP → 数学家失业

优化问题轻松解决：
• 调度、规划、资源分配
• 都是NP问题
• 如果P=NP → 完美优化

创造力失去价值：
• 找到解决方案 = 验证方案
• 创新和执行同样容易
```

## 📖 NP完全问题

### 1. 定义

```
问题X是NP完全的，当且仅当：
1. X ∈ NP（能多项式时间验证）
2. X是NP-hard（NP中任何问题都可以归约到X）

NP-hard：至少和NP中最难的问题一样难

关系：
        所有问题
         /  \
       P    NP
            / \
      NP-Easy NP-complete
                \
              NP-hard

NP完全 = NP ∩ NP-hard
```

### 2. Cook-Levin定理

```
SAT是NP完全的（第一个NP完全问题）

证明思路：
1. SAT ∈ NP（容易验证）
2. 任何NP问题都可以归约到SAT

关键洞察：
• 计算机程序 = 电路 = 布尔公式
• 任何多项式时间验证程序都可以编码为SAT
• "存在使程序返回true的输入" = SAT问题

革命性影响：
• 找到了第一个NP完全问题
• 开启了NP完全理论
```

### 3. 经典NP完全问题

#### SAT（布尔可满足性）

```
输入：布尔公式F
问题：F可满足吗？

例子：
F = (x₁ ∨ x₂) ∧ (¬x₁ ∨ x₃)
答案：是（x₁=true, x₂=任意, x₃=true）

变种：
• 3-SAT：每个子句恰好3个文字
• 2-SAT：每个子句恰好2个文字（P问题！）

应用：
• 硬件验证
• 程序验证
• AI规划
```

#### 3-SAT（更简单的变种）

```
输入：每个子句恰好3个文字的CNF公式
问题：可满足吗？

例子：
(x₁ ∨ x₂ ∨ x₃) ∧ (¬x₁ ∨ x₂ ∨ ¬x₄) ∧ ...

仍然是NP完全的！

但2-SAT是P：
(x₁ ∨ x₂) ∧ (¬x₁ ∨ x₃)
可以用图算法O(n)解决
```

#### 顶点覆盖

```
输入：图G=(V,E)，整数k
问题：存在大小≤k的顶点子集S，使得每条边至少有一个端点在S中吗？

例子：
    1 --- 2
    |     |
    3 --- 4

k=2：{1,4}或{2,3}
k=1：不存在

应用：
• 监控摄像头放置
• 基站选址
```

#### 独立集

```
输入：图G=(V,E)，整数k
问题：存在大小≥k的顶点子集S，使得S中任意两点不相邻吗？

例子：
    1 --- 2
    |     |
    3 --- 4

k=2：{1,4}或{2,3}
k=3：不存在

关系：
独立集 ↔ 顶点覆盖（互补）
```

#### 团问题（Clique）

```
输入：图G=(V,E)，整数k
问题：存在大小≥k的完全子图吗？

例子：
    1 --- 2
    |  X  |
    3 --- 4

k=3：{1,2,3}（假设都连）
k=4：{1,2,3,4}（假设完全图）

应用：
• 社交网络分析
• 生物信息学
```

#### 哈密尔顿回路

```
输入：图G=(V,E)
问题：存在访问每个顶点恰好一次的回路吗？

例子：
    1 --- 2
    |     |
    3 --- 4

回路：1-2-4-3-1 ✓

应用：
• 路径规划
• DNA测序
```

#### 旅行商问题（TSP）

```
输入：n个城市，距离矩阵d[i][j]，目标距离D
问题：存在总距离≤D的回路访问所有城市吗？

例子：
城市：A, B, C, D
距离：
  A B C D
A 0 1 4 3
B 1 0 2 5
C 4 2 0 1
D 3 5 1 0

路径A-B-C-D-A：1+2+1+3=7

应用：
• 物流配送
• 芯片制造
• 基因组装
```

#### 子集和

```
输入：集合S={s₁,...,sₙ}，目标t
问题：存在子集和为t吗？

例子：
S = {3, 34, 4, 12, 5, 2}
t = 9
答案：{4, 5} ✓

应用：
• 资源分配
• 密码学
```

#### 背包问题

```
输入：n个物品（重量w[i]，价值v[i]），容量W，目标价值V
问题：存在总重量≤W，总价值≥V的子集吗？

例子：
物品：(重量,价值) = {(2,3), (3,4), (4,5), (5,6)}
容量：9
目标价值：12

选择：{(3,4), (4,5), (2,3)} 重量9，价值12 ✓

应用：
• 投资组合
• 资源分配
• 切割问题
```

#### 图着色

```
输入：图G=(V,E)，整数k
问题：能用k种颜色给顶点着色，使相邻顶点颜色不同吗？

例子：
    1 --- 2
    |     |
    3 --- 4

k=2：1,4用红，2,3用蓝 ✓
k=1：不可能

特殊情况：
• k=2：二分图判定（P问题）
• k≥3：NP完全

应用：
• 调度问题
• 频率分配
• 寄存器分配
```

### 4. 归约（Reduction）

#### 什么是归约？

```
归约：把问题A转化为问题B

A ≤ₚ B（A多项式归约到B）：
• 存在多项式时间算法，把A的实例转为B的实例
• A的答案 = B的答案

含义：
• 如果能解B，就能解A
• B至少和A一样难

用途：
• 证明B是NP完全的
• 如果A是NP完全，且A ≤ₚ B，则B是NP完全
```

#### 归约链

```
经典归约链：

SAT
 ↓
3-SAT
 ↓
独立集 ↔ 顶点覆盖 ↔ 团问题
 ↓
哈密尔顿回路
 ↓
TSP
 ↓
子集和
 ↓
背包问题

证明新问题X是NP完全：
1. 证明X ∈ NP
2. 选择已知NP完全问题Y
3. 证明Y ≤ₚ X
```

#### 归约例子：3-SAT → 独立集

```
3-SAT实例：
(x₁ ∨ x₂ ∨ x₃) ∧ (¬x₁ ∨ x₂ ∨ ¬x₄)

构造图：
• 每个子句 → 3个顶点（对应3个文字）
• 同一子句内的顶点：两两相连
• 矛盾的文字：连边（如x₁和¬x₁）

          子句1              子句2
       x₁  x₂  x₃       ¬x₁  x₂  ¬x₄
        △              △
       /|\            /|\
      ---            ---
       |                |
       └────────────────┘ (x₁和¬x₁矛盾)

独立集大小k = 子句数

正确性：
• 3-SAT可满足 ⟺ 存在大小k的独立集
• 独立集 = 选择的文字（每个子句选一个）
• 独立 = 不矛盾
```

#### 归约例子：独立集 → 顶点覆盖

```
简单的转换：

独立集S ↔ 顶点覆盖V\S（补集）

为什么？
• S是独立集 ⟺ S内无边
• ⟺ 所有边至少有一个端点在V\S
• ⟺ V\S是顶点覆盖

问题转换：
"是否存在大小≥k的独立集"
↓
"是否存在大小≤(n-k)的顶点覆盖"

归约时间：O(1)（只是补集）
```

## 🔧 应对NP完全问题

### 1. 精确算法（指数时间）

```python
# 回溯法
def subset_sum_backtrack(arr, target, index=0, current_sum=0):
    if current_sum == target:
        return True
    if index >= len(arr) or current_sum > target:
        return False

    # 选择当前元素
    if subset_sum_backtrack(arr, target, index+1, current_sum+arr[index]):
        return True
    # 不选择当前元素
    if subset_sum_backtrack(arr, target, index+1, current_sum):
        return True

    return False

# 时间：O(2ⁿ)
# 小数据可行（n < 25）

# 动态规划（伪多项式）
def subset_sum_dp(arr, target):
    dp = [False] * (target + 1)
    dp[0] = True

    for num in arr:
        for i in range(target, num-1, -1):
            if dp[i-num]:
                dp[i] = True

    return dp[target]

# 时间：O(n × target)
# target小时高效
```

### 2. 近似算法

```python
# TSP的2-近似算法
def tsp_2_approximation(graph):
    # 1. 找最小生成树
    mst = minimum_spanning_tree(graph)

    # 2. DFS遍历MST
    tour = dfs_preorder(mst)

    # 3. 直接连接（三角不等式）
    return tour

# 保证：近似解 ≤ 2 × 最优解
# 时间：O(V²)

# 顶点覆盖的2-近似
def vertex_cover_approximation(graph):
    cover = set()
    edges = list(graph.edges())

    while edges:
        # 选择任意边(u,v)
        u, v = edges[0]
        cover.add(u)
        cover.add(v)

        # 删除所有关联边
        edges = [(a,b) for a,b in edges
                 if a != u and a != v and b != u and b != v]

    return cover

# 保证：|近似解| ≤ 2 × |最优解|
# 时间：O(E)
```

### 3. 启发式算法

```python
# TSP的贪心启发式
def tsp_greedy(graph):
    n = len(graph)
    visited = [False] * n
    tour = [0]  # 从城市0开始
    visited[0] = True

    for _ in range(n - 1):
        current = tour[-1]
        # 选择最近的未访问城市
        nearest = min((i for i in range(n) if not visited[i]),
                      key=lambda i: graph[current][i])
        tour.append(nearest)
        visited[nearest] = True

    tour.append(0)  # 回到起点
    return tour

# 无法保证近似比
# 但实践中常常很好

# 模拟退火
def simulated_annealing(problem, max_iter=10000):
    current = random_solution()
    best = current
    temperature = 1000

    for i in range(max_iter):
        neighbor = random_neighbor(current)
        delta = cost(neighbor) - cost(current)

        if delta < 0 or random.random() < exp(-delta/temperature):
            current = neighbor
            if cost(current) < cost(best):
                best = current

        temperature *= 0.99  # 降温

    return best

# 启发式，无保证
# 但常能找到很好的解
```

### 4. 特殊情况

```python
# 某些NP完全问题的特殊情况是P的

# 2-SAT（P问题）
def solve_2sat(clauses):
    # 构造蕴含图
    # 使用强连通分量
    # O(n)时间
    pass

# 平面图的顶点覆盖
# 树结构的哈密尔顿回路
# 固定参数k的问题（参数化复杂度）
```

## 💡 实际影响

### 1. 认识问题难度

```
遇到新问题时：

1. 尝试多项式算法
2. 如果找不到，怀疑是NP完全
3. 尝试归约到已知NP完全问题
4. 如果是NP完全：
   • 不要浪费时间找完美算法
   • 使用近似/启发式
   • 或限制问题规模
```

### 2. 问题建模

```
避免建模成NP完全问题：

❌ 差的建模：
   "找最优的X"（可能NP完全）

✓ 好的建模：
   "找任何满足条件的X"（可能P）
   "找近似最优的X"（近似算法）

例子：调度问题
• 最优调度：NP完全
• 2-近似调度：P
```

### 3. 算法选择

```
实际应用：

小数据（n < 30）：
• 精确算法（回溯、DP）

中等数据（30 < n < 1000）：
• 近似算法
• 启发式

大数据（n > 1000）：
• 贪心启发式
• 局部搜索
• 随机算法
```

## 🔗 与其他概念的联系

### 与可计算性
- **可计算性** - 能不能算
- **复杂度** - 多快能算
- NP完全 - 可计算但可能很慢

参考：`theory/computation-theory/computability.md`

### 与算法设计
- **贪心** - 近似算法的基础
- **动态规划** - 伪多项式算法
- **分治** - 某些特殊情况

参考：`fundamentals/algorithms/`

### 与密码学
- **RSA** - 基于大数分解（NP问题）
- **P=NP** - 密码学崩溃

参考：`applications/cryptography/`

## 📖 扩展阅读

### 未解之谜
- P vs NP（千禧年七大数学难题之一）
- 100万美元奖金

### 其他复杂度类
- co-NP（补问题）
- PSPACE（多项式空间）
- EXPTIME（指数时间）
- BPP（随机多项式）
- BQP（量子多项式）

### 参数化复杂度
- FPT（固定参数可行）
- W-层次
- 核化

---

**理解NP完全性，你就知道哪些问题值得优化，哪些需要妥协！** 🧩

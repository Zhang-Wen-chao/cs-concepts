# æ—¶é—´ä¸ç©ºé—´å¤æ‚åº¦ (Time and Space Complexity)

> è¡¡é‡ç®—æ³•æ•ˆç‡çš„æ ‡å°º

## ğŸ¯ æ ¸å¿ƒæ€æƒ³

å¤æ‚åº¦åˆ†æå›ç­”ä¸€ä¸ªé—®é¢˜ï¼š**ç®—æ³•éœ€è¦å¤šå°‘èµ„æºï¼Ÿ**

**ä¸€å¥è¯ç†è§£ï¼š**
- æ—¶é—´å¤æ‚åº¦ = è¿è¡Œéœ€è¦å¤šå°‘æ­¥
- ç©ºé—´å¤æ‚åº¦ = è¿è¡Œéœ€è¦å¤šå°‘å†…å­˜

**ä¸ºä»€ä¹ˆé‡è¦ï¼š**
```
åŒæ ·çš„é—®é¢˜ï¼Œä¸åŒç®—æ³•æ•ˆç‡å·®å¼‚å·¨å¤§ï¼š

æŸ¥æ‰¾é—®é¢˜ï¼ˆåœ¨nä¸ªå…ƒç´ ä¸­æ‰¾ä¸€ä¸ªï¼‰ï¼š
â€¢ çº¿æ€§æŸ¥æ‰¾ï¼šO(n)          1000ä¸ªå…ƒç´  â†’ 1000æ­¥
â€¢ äºŒåˆ†æŸ¥æ‰¾ï¼šO(log n)      1000ä¸ªå…ƒç´  â†’ 10æ­¥

æ’åºé—®é¢˜ï¼ˆç»™nä¸ªå…ƒç´ æ’åºï¼‰ï¼š
â€¢ å†’æ³¡æ’åºï¼šO(nÂ²)         1000ä¸ªå…ƒç´  â†’ 1,000,000æ­¥
â€¢ å¿«é€Ÿæ’åºï¼šO(n log n)    1000ä¸ªå…ƒç´  â†’ 10,000æ­¥

å·®è·100å€ï¼
```

## ğŸ“– æ—¶é—´å¤æ‚åº¦

### 1. ä»€ä¹ˆæ˜¯æ—¶é—´å¤æ‚åº¦ï¼Ÿ

#### ç›´è§‚ç†è§£

```
æ—¶é—´å¤æ‚åº¦ = ç®—æ³•æ‰§è¡Œçš„"åŸºæœ¬æ“ä½œ"æ¬¡æ•°ï¼ˆå…³äºè¾“å…¥è§„æ¨¡nï¼‰

ä¸æ˜¯ï¼š
âœ— å®é™…è¿è¡Œçš„ç§’æ•°ï¼ˆå’Œç¡¬ä»¶ç›¸å…³ï¼‰
âœ— ä»£ç çš„è¡Œæ•°

è€Œæ˜¯ï¼š
âœ“ æ“ä½œæ¬¡æ•°éšè¾“å…¥å¢é•¿çš„è¶‹åŠ¿
âœ“ ä¸å…·ä½“å¸¸æ•°æ— å…³çš„"å¢é•¿ç‡"
```

#### ä¾‹å­

```python
# ä¾‹1ï¼šå¸¸æ•°æ—¶é—´
def get_first(arr):
    return arr[0]        # 1æ¬¡æ“ä½œ

æ—¶é—´å¤æ‚åº¦ï¼šO(1)
æ— è®ºæ•°ç»„å¤šå¤§ï¼Œéƒ½åªéœ€1æ­¥

# ä¾‹2ï¼šçº¿æ€§æ—¶é—´
def sum_array(arr):
    total = 0
    for x in arr:        # næ¬¡å¾ªç¯
        total += x       # æ¯æ¬¡1æ¬¡æ“ä½œ
    return total

æ—¶é—´å¤æ‚åº¦ï¼šO(n)
nä¸ªå…ƒç´  â†’ næ¬¡åŠ æ³•

# ä¾‹3ï¼šå¹³æ–¹æ—¶é—´
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):       # næ¬¡å¤–å¾ªç¯
        for j in range(n):   # næ¬¡å†…å¾ªç¯
            if arr[i] < arr[j]:
                arr[i], arr[j] = arr[j], arr[i]

æ—¶é—´å¤æ‚åº¦ï¼šO(nÂ²)
n Ã— n = nÂ²æ¬¡æ¯”è¾ƒ

# ä¾‹4ï¼šå¯¹æ•°æ—¶é—´
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

æ—¶é—´å¤æ‚åº¦ï¼šO(log n)
æ¯æ¬¡å‡åŠæœç´¢ç©ºé—´
```

### 2. å¤§Oè®°å· (Big-O Notation)

#### å®šä¹‰

```
f(n) = O(g(n)) è¡¨ç¤ºï¼š
å½“nè¶³å¤Ÿå¤§æ—¶ï¼Œf(n) â‰¤ c Ã— g(n)ï¼ˆå­˜åœ¨å¸¸æ•°cï¼‰

ç›´è§‚ç†è§£ï¼š
â€¢ f(n)çš„å¢é•¿é€Ÿåº¦ä¸è¶…è¿‡g(n)
â€¢ å¿½ç•¥å¸¸æ•°å› å­å’Œä½é˜¶é¡¹

ä¾‹å­ï¼š
3nÂ² + 5n + 10 = O(nÂ²)
å› ä¸ºï¼šå½“nå¾ˆå¤§æ—¶ï¼ŒnÂ²é¡¹ä¸»å¯¼ä¸€åˆ‡
```

#### ä¸ºä»€ä¹ˆå¿½ç•¥å¸¸æ•°ï¼Ÿ

```
å®é™…è¿è¡Œæ—¶é—´ = câ‚ Ã— nÂ² + câ‚‚ Ã— n + câ‚ƒ

å¸¸æ•°câ‚, câ‚‚, câ‚ƒå–å†³äºï¼š
â€¢ ç¡¬ä»¶é€Ÿåº¦
â€¢ ç¼–è¯‘å™¨ä¼˜åŒ–
â€¢ æ“ä½œç³»ç»Ÿ
â€¢ ç¼–ç¨‹è¯­è¨€

å¤æ‚åº¦åˆ†æå…³æ³¨ï¼š
â€¢ ç®—æ³•æœ¬è´¨çš„å¢é•¿è¶‹åŠ¿
â€¢ ä¸å…·ä½“å®ç°æ— å…³çš„ç‰¹æ€§

å½“nå¾ˆå¤§æ—¶ï¼š
â€¢ 2nÂ²å’Œ1000nÂ²å¢é•¿è¶‹åŠ¿ç›¸åŒï¼ˆéƒ½æ˜¯O(nÂ²)ï¼‰
â€¢ ä½†nÂ²å’Œn log nå¢é•¿è¶‹åŠ¿ä¸åŒ
```

### 3. å¸¸è§å¤æ‚åº¦ç±»

```
ä»å¿«åˆ°æ…¢ï¼š

O(1)         å¸¸æ•°æ—¶é—´
O(log n)     å¯¹æ•°æ—¶é—´
O(n)         çº¿æ€§æ—¶é—´
O(n log n)   çº¿æ€§å¯¹æ•°æ—¶é—´
O(nÂ²)        å¹³æ–¹æ—¶é—´
O(nÂ³)        ç«‹æ–¹æ—¶é—´
O(2â¿)        æŒ‡æ•°æ—¶é—´
O(n!)        é˜¶ä¹˜æ—¶é—´

å¯è§†åŒ–ï¼ˆn=1000ï¼‰ï¼š
O(1):        1æ­¥
O(log n):    10æ­¥
O(n):        1,000æ­¥
O(n log n):  10,000æ­¥
O(nÂ²):       1,000,000æ­¥
O(2â¿):       2Â¹â°â°â°æ­¥ï¼ˆå®‡å®™åŸå­æ€»æ•°çš„çº§åˆ«ï¼‰
O(n!):       æ— æ³•è®¡ç®—
```

#### O(1) - å¸¸æ•°æ—¶é—´

```python
# æ•°ç»„è®¿é—®
def access(arr, i):
    return arr[i]

# å“ˆå¸Œè¡¨æŸ¥è¯¢
def lookup(hash_map, key):
    return hash_map[key]

# æ ˆæ“ä½œ
def push(stack, item):
    stack.append(item)

ç‰¹ç‚¹ï¼š
â€¢ æ“ä½œæ¬¡æ•°ä¸è¾“å…¥è§„æ¨¡æ— å…³
â€¢ æœ€ç†æƒ³çš„å¤æ‚åº¦
```

#### O(log n) - å¯¹æ•°æ—¶é—´

```python
# äºŒåˆ†æŸ¥æ‰¾
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# ä¸ºä»€ä¹ˆæ˜¯O(log n)ï¼Ÿ
æ¯æ¬¡å¾ªç¯ï¼Œæœç´¢ç©ºé—´å‡åŠï¼š
n â†’ n/2 â†’ n/4 â†’ n/8 â†’ ... â†’ 1
éœ€è¦å¤šå°‘æ­¥ï¼Ÿlogâ‚‚(n)æ­¥

# å¹³è¡¡äºŒå‰æ ‘æ“ä½œ
def tree_search(root, target):
    # æ¯æ¬¡é€‰æ‹©ä¸€ä¸ªå­æ ‘
    # æ ‘é«˜ = O(log n)
    pass

ä¾‹å­ï¼š
n = 1024
logâ‚‚(1024) = 10
åªéœ€10æ­¥ï¼
```

#### O(n) - çº¿æ€§æ—¶é—´

```python
# éå†æ•°ç»„
def find_max(arr):
    max_val = arr[0]
    for x in arr:           # næ¬¡
        if x > max_val:
            max_val = x
    return max_val

# é“¾è¡¨éå†
def count_nodes(head):
    count = 0
    current = head
    while current:          # næ¬¡
        count += 1
        current = current.next
    return count

ç‰¹ç‚¹ï¼š
â€¢ æ¯ä¸ªå…ƒç´ å¤„ç†ä¸€æ¬¡
â€¢ å¸¸è§ä¸”é«˜æ•ˆ
```

#### O(n log n) - çº¿æ€§å¯¹æ•°æ—¶é—´

```python
# å½’å¹¶æ’åº
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])      # T(n/2)
    right = merge_sort(arr[mid:])     # T(n/2)
    return merge(left, right)         # O(n)

# é€’å½’æ ‘ï¼š
#       n             1å±‚ï¼Œæ¯å±‚O(n)å·¥ä½œ
#      / \
#    n/2 n/2          2å±‚ï¼Œæ¯å±‚O(n)å·¥ä½œ
#    / \ / \
#  n/4...  ...        4å±‚ï¼Œæ¯å±‚O(n)å·¥ä½œ
#  ...
# æ€»å…±log(n)å±‚ï¼Œæ¯å±‚O(n) â†’ O(n log n)

# å¿«é€Ÿæ’åºï¼ˆå¹³å‡ï¼‰
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[0]
    left = [x for x in arr[1:] if x <= pivot]
    right = [x for x in arr[1:] if x > pivot]
    return quick_sort(left) + [pivot] + quick_sort(right)

ç‰¹ç‚¹ï¼š
â€¢ æœ€ä¼˜æ¯”è¾ƒæ’åºçš„å¤æ‚åº¦
â€¢ åˆ†æ²»ç®—æ³•å¸¸è§å¤æ‚åº¦
```

#### O(nÂ²) - å¹³æ–¹æ—¶é—´

```python
# å†’æ³¡æ’åº
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):              # næ¬¡
        for j in range(n - i - 1):  # næ¬¡
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

# é€‰æ‹©æ’åº
def selection_sort(arr):
    for i in range(len(arr)):       # næ¬¡
        min_idx = i
        for j in range(i+1, len(arr)):  # næ¬¡
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

# åµŒå¥—å¾ªç¯
def print_pairs(arr):
    for i in arr:                   # næ¬¡
        for j in arr:               # næ¬¡
            print(i, j)             # nÂ²æ¬¡è¾“å‡º

ç‰¹ç‚¹ï¼š
â€¢ åµŒå¥—å¾ªç¯
â€¢ å°æ•°æ®å¯æ¥å—ï¼Œå¤§æ•°æ®æ…¢
```

#### O(2â¿) - æŒ‡æ•°æ—¶é—´

```python
# æ–æ³¢é‚£å¥‘ï¼ˆæœ´ç´ é€’å½’ï¼‰
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)

# é€’å½’æ ‘ï¼š
#           fib(5)
#          /      \
#      fib(4)    fib(3)
#      /   \      /   \
#   fib(3) fib(2) ...
#   ...

# èŠ‚ç‚¹æ•°ï¼š2â° + 2Â¹ + 2Â² + ... + 2â¿ â‰ˆ 2â¿

# å­é›†ç”Ÿæˆ
def subsets(arr):
    if not arr:
        return [[]]
    first = arr[0]
    rest = subsets(arr[1:])
    return rest + [[first] + s for s in rest]

# æ¯ä¸ªå…ƒç´ ï¼šé€‰æˆ–ä¸é€‰ â†’ 2â¿ç§ç»„åˆ

ç‰¹ç‚¹ï¼š
â€¢ éå¸¸æ…¢ï¼
â€¢ n=30å°±å¾ˆéš¾ç®—
â€¢ é€šå¸¸éœ€è¦ä¼˜åŒ–
```

#### O(n!) - é˜¶ä¹˜æ—¶é—´

```python
# å…¨æ’åˆ—
def permutations(arr):
    if len(arr) <= 1:
        return [arr]
    result = []
    for i in range(len(arr)):
        rest = arr[:i] + arr[i+1:]
        for p in permutations(rest):
            result.append([arr[i]] + p)
    return result

# æ—…è¡Œå•†é—®é¢˜ï¼ˆæš´åŠ›ï¼‰
def tsp_brute_force(cities):
    # å°è¯•æ‰€æœ‰å¯èƒ½çš„è·¯å¾„
    # nä¸ªåŸå¸‚ â†’ n!ç§è·¯å¾„
    pass

ç‰¹ç‚¹ï¼š
â€¢ ææ…¢ï¼
â€¢ n=10 â†’ 3,628,800
â€¢ n=20 â†’ 2.4 Ã— 10Â¹â¸ï¼ˆå‡ åƒå¹´ï¼‰
```

### 4. å¤æ‚åº¦åˆ†ææŠ€å·§

#### å¾ªç¯è§„åˆ™

```python
# å•å¾ªç¯ï¼šO(n)
for i in range(n):
    print(i)

# åµŒå¥—å¾ªç¯ï¼šç›¸ä¹˜
for i in range(n):        # O(n)
    for j in range(m):    # O(m)
        print(i, j)       # O(n Ã— m)

# é¡ºåºè¯­å¥ï¼šç›¸åŠ 
for i in range(n):        # O(n)
    print(i)
for j in range(m):        # O(m)
    print(j)
# æ€»å…±ï¼šO(n + m) = O(max(n, m))

# é€’å‡å¾ªç¯
for i in range(n, 0, -1):     # næ¬¡
    for j in range(i):        # iæ¬¡
        print(i, j)
# 1 + 2 + 3 + ... + n = n(n+1)/2 = O(nÂ²)
```

#### é€’å½’åˆ†æ

```python
# é€’å½’å…³ç³» â†’ ä¸»å®šç†

# ä¾‹1ï¼šäºŒåˆ†æŸ¥æ‰¾
def binary_search(arr, target):
    if len(arr) == 0:
        return -1
    mid = len(arr) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search(arr[mid+1:], target)
    else:
        return binary_search(arr[:mid], target)

# é€’å½’å¼ï¼šT(n) = T(n/2) + O(1)
# è§£ï¼šT(n) = O(log n)

# ä¾‹2ï¼šå½’å¹¶æ’åº
# T(n) = 2T(n/2) + O(n)
# è§£ï¼šT(n) = O(n log n)

# ä¾‹3ï¼šæ–æ³¢é‚£å¥‘ï¼ˆæœ´ç´ ï¼‰
# T(n) = T(n-1) + T(n-2) + O(1)
# è§£ï¼šT(n) = O(2â¿)ï¼ˆæ¥è¿‘æŒ‡æ•°ï¼‰
```

#### ä¸»å®šç† (Master Theorem)

```
å¯¹äºé€’å½’å¼ï¼šT(n) = aT(n/b) + f(n)

aï¼šå­é—®é¢˜ä¸ªæ•°
bï¼šå­é—®é¢˜è§„æ¨¡ç¼©å°å€æ•°
f(n)ï¼šåˆå¹¶ä»£ä»·

æƒ…å†µ1ï¼šf(n) = O(n^c)ï¼Œå…¶ä¸­c < log_b(a)
     â†’ T(n) = O(n^(log_b(a)))

æƒ…å†µ2ï¼šf(n) = O(n^c log^k(n))ï¼Œå…¶ä¸­c = log_b(a)
     â†’ T(n) = O(n^c log^(k+1)(n))

æƒ…å†µ3ï¼šf(n) = O(n^c)ï¼Œå…¶ä¸­c > log_b(a)
     â†’ T(n) = O(f(n))

ä¾‹å­ï¼š
T(n) = 2T(n/2) + O(n)
a=2, b=2, c=1
logâ‚‚(2) = 1 = c â†’ æƒ…å†µ2
T(n) = O(n log n)
```

### 5. æœ€å¥½ã€æœ€åã€å¹³å‡æƒ…å†µ

```python
# å¿«é€Ÿæ’åº
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[0]
    left = [x for x in arr[1:] if x <= pivot]
    right = [x for x in arr[1:] if x > pivot]
    return quick_sort(left) + [pivot] + quick_sort(right)

æœ€å¥½æƒ…å†µï¼šO(n log n)
  â€¢ æ¯æ¬¡pivotæ­£å¥½åœ¨ä¸­é—´
  â€¢ å®Œç¾åˆ†å‰²

æœ€åæƒ…å†µï¼šO(nÂ²)
  â€¢ æ¯æ¬¡pivotæ˜¯æœ€å°/æœ€å¤§å€¼
  â€¢ å¦‚ï¼šå·²æ’åºæ•°ç»„ï¼Œé€‰ç¬¬ä¸€ä¸ªä¸ºpivot
  â€¢ é€€åŒ–ä¸ºå†’æ³¡æ’åº

å¹³å‡æƒ…å†µï¼šO(n log n)
  â€¢ éšæœºè¾“å…¥
  â€¢ pivotåœ¨ä¸­é—´é™„è¿‘çš„æ¦‚ç‡å¤§

å®è·µï¼š
â€¢ éšæœºé€‰æ‹©pivotï¼ˆé¿å…æœ€åæƒ…å†µï¼‰
â€¢ æˆ–ä½¿ç”¨ä¸‰æ•°å–ä¸­
```

```python
# çº¿æ€§æŸ¥æ‰¾
def linear_search(arr, target):
    for i, x in enumerate(arr):
        if x == target:
            return i
    return -1

æœ€å¥½æƒ…å†µï¼šO(1)
  â€¢ targetåœ¨ç¬¬ä¸€ä¸ªä½ç½®

æœ€åæƒ…å†µï¼šO(n)
  â€¢ targetåœ¨æœ€åæˆ–ä¸å­˜åœ¨

å¹³å‡æƒ…å†µï¼šO(n)
  â€¢ å¹³å‡éœ€è¦æ£€æŸ¥n/2ä¸ªå…ƒç´ 
  â€¢ ä»æ˜¯O(n)
```

## ğŸ“– ç©ºé—´å¤æ‚åº¦

### 1. ä»€ä¹ˆæ˜¯ç©ºé—´å¤æ‚åº¦ï¼Ÿ

```
ç©ºé—´å¤æ‚åº¦ = ç®—æ³•ä½¿ç”¨çš„é¢å¤–å†…å­˜ï¼ˆå…³äºè¾“å…¥è§„æ¨¡nï¼‰

åŒ…æ‹¬ï¼š
âœ“ åŠ¨æ€åˆ†é…çš„å†…å­˜
âœ“ é€’å½’è°ƒç”¨æ ˆ
âœ“ ä¸´æ—¶å˜é‡

ä¸åŒ…æ‹¬ï¼š
âœ— è¾“å…¥æœ¬èº«å ç”¨çš„ç©ºé—´
âœ— è¾“å‡ºå ç”¨çš„ç©ºé—´
```

### 2. å¸¸è§ç©ºé—´å¤æ‚åº¦

#### O(1) - å¸¸æ•°ç©ºé—´

```python
# åŸåœ°äº¤æ¢
def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]
    # åªç”¨äº†å‡ ä¸ªå˜é‡

# è¿­ä»£æ±‚å’Œ
def sum_iterative(arr):
    total = 0      # O(1)ç©ºé—´
    for x in arr:
        total += x
    return total

# åŸåœ°åè½¬
def reverse_in_place(arr):
    left, right = 0, len(arr) - 1
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1
```

#### O(n) - çº¿æ€§ç©ºé—´

```python
# å¤åˆ¶æ•°ç»„
def copy_array(arr):
    return arr[:]    # æ–°æ•°ç»„O(n)ç©ºé—´

# å½’å¹¶æ’åº
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])   # é€’å½’æ·±åº¦O(log n)
    right = merge_sort(arr[mid:])  # ä½†æ¯å±‚åˆå¹¶éœ€è¦O(n)
    return merge(left, right)      # ä¸´æ—¶æ•°ç»„O(n)

# æ€»ç©ºé—´ï¼šO(n)

# å“ˆå¸Œè¡¨
def count_frequency(arr):
    freq = {}           # O(n)ç©ºé—´
    for x in arr:
        freq[x] = freq.get(x, 0) + 1
    return freq
```

#### O(log n) - å¯¹æ•°ç©ºé—´

```python
# äºŒåˆ†æŸ¥æ‰¾ï¼ˆé€’å½’ï¼‰
def binary_search_recursive(arr, target, left, right):
    if left > right:
        return -1
    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid+1, right)
    else:
        return binary_search_recursive(arr, target, left, mid-1)

# é€’å½’æ·±åº¦ï¼šO(log n)
# æ¯æ¬¡è°ƒç”¨æ ˆå¸§ï¼šO(1)
# æ€»ç©ºé—´ï¼šO(log n)

# å¿«é€Ÿæ’åºï¼ˆåŸåœ°ï¼Œå¹³å‡ï¼‰
# é€’å½’æ·±åº¦ï¼šO(log n)
# æ¯æ¬¡è°ƒç”¨ï¼šO(1)
# æ€»ç©ºé—´ï¼šO(log n)
```

### 3. æ—¶é—´-ç©ºé—´æƒè¡¡

```python
# æ–æ³¢é‚£å¥‘æ•°åˆ—

# ç‰ˆæœ¬1ï¼šæŒ‡æ•°æ—¶é—´ï¼Œå¸¸æ•°ç©ºé—´
def fib_slow(n):
    if n <= 1:
        return n
    return fib_slow(n-1) + fib_slow(n-2)
# æ—¶é—´ï¼šO(2â¿)ï¼Œç©ºé—´ï¼šO(n)ï¼ˆé€’å½’æ ˆï¼‰

# ç‰ˆæœ¬2ï¼šçº¿æ€§æ—¶é—´ï¼Œçº¿æ€§ç©ºé—´ï¼ˆåŠ¨æ€è§„åˆ’ï¼‰
def fib_dp(n):
    if n <= 1:
        return n
    dp = [0] * (n + 1)
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
# æ—¶é—´ï¼šO(n)ï¼Œç©ºé—´ï¼šO(n)

# ç‰ˆæœ¬3ï¼šçº¿æ€§æ—¶é—´ï¼Œå¸¸æ•°ç©ºé—´ï¼ˆä¼˜åŒ–ï¼‰
def fib_optimal(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b
# æ—¶é—´ï¼šO(n)ï¼Œç©ºé—´ï¼šO(1)

æƒè¡¡ï¼š
â€¢ ç‰ˆæœ¬1ï¼šç®€å•ä½†ææ…¢
â€¢ ç‰ˆæœ¬2ï¼šå¿«ä½†ç”¨æ›´å¤šå†…å­˜
â€¢ ç‰ˆæœ¬3ï¼šæœ€ä¼˜è§£
```

## ğŸ”§ å®é™…åº”ç”¨

### 1. é€‰æ‹©æ•°æ®ç»“æ„

```
æ“ä½œ             æ•°ç»„    é“¾è¡¨    å“ˆå¸Œè¡¨   å¹³è¡¡æ ‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
è®¿é—®ç¬¬iä¸ªå…ƒç´     O(1)    O(n)    N/A     O(log n)
æœç´¢å…ƒç´          O(n)    O(n)    O(1)    O(log n)
æ’å…¥ï¼ˆå¼€å¤´ï¼‰     O(n)    O(1)    O(1)    O(log n)
æ’å…¥ï¼ˆæœ«å°¾ï¼‰     O(1)*   O(1)    O(1)    O(log n)
åˆ é™¤             O(n)    O(n)    O(1)    O(log n)

*å‡è®¾ä¸éœ€è¦æ‰©å®¹

é€‰æ‹©ä¾æ®ï¼š
â€¢ é¢‘ç¹éšæœºè®¿é—® â†’ æ•°ç»„
â€¢ é¢‘ç¹æ’å…¥åˆ é™¤ â†’ é“¾è¡¨
â€¢ éœ€è¦å¿«é€ŸæŸ¥æ‰¾ â†’ å“ˆå¸Œè¡¨
â€¢ éœ€è¦æœ‰åº+æŸ¥æ‰¾ â†’ å¹³è¡¡æ ‘
```

### 2. ç®—æ³•é€‰æ‹©

```
é—®é¢˜ï¼šæ’åºnä¸ªå…ƒç´ 

å°æ•°æ®ï¼ˆn < 100ï¼‰ï¼š
â€¢ æ’å…¥æ’åº O(nÂ²) - ç®€å•ï¼Œå¸¸æ•°å°

ä¸­ç­‰æ•°æ®ï¼ˆ100 < n < 10000ï¼‰ï¼š
â€¢ å¿«é€Ÿæ’åº O(n log n) - å¹³å‡æœ€å¿«

å¤§æ•°æ®ï¼ˆn > 10000ï¼‰ï¼š
â€¢ å½’å¹¶æ’åº O(n log n) - ç¨³å®šï¼Œå¯é¢„æµ‹

ç‰¹æ®Šæƒ…å†µï¼š
â€¢ å‡ ä¹æœ‰åº â†’ æ’å…¥æ’åº O(n)
â€¢ èŒƒå›´å°ï¼ˆå¦‚å¹´é¾„ï¼‰ â†’ è®¡æ•°æ’åº O(n+k)
â€¢ å­—ç¬¦ä¸² â†’ åŸºæ•°æ’åº O(nk)
```

### 3. æ€§èƒ½ä¼°ç®—

```
å®é™…è¿è¡Œæ—¶é—´ä¼°ç®—ï¼š

å‡è®¾ï¼šç°ä»£è®¡ç®—æœºæ¯ç§’10â¸æ¬¡æ“ä½œ

n = 10â¶ï¼ˆ100ä¸‡ï¼‰ï¼š
O(log n):     20æ¬¡æ“ä½œ           â‰ˆ ç¬é—´
O(n):         10â¶æ¬¡æ“ä½œ          â‰ˆ 0.01ç§’
O(n log n):   2Ã—10â·æ¬¡æ“ä½œ        â‰ˆ 0.2ç§’
O(nÂ²):        10Â¹Â²æ¬¡æ“ä½œ         â‰ˆ 3å°æ—¶
O(2â¿):        æ— æ³•è®¡ç®—           â‰ˆ å®‡å®™å¹´é¾„

å®è·µå‡†åˆ™ï¼š
â€¢ O(1), O(log n), O(n) â†’ ä»»ä½•è§„æ¨¡éƒ½OK
â€¢ O(n log n) â†’ n < 10â·å¯æ¥å—
â€¢ O(nÂ²) â†’ n < 10â´å¯æ¥å—
â€¢ O(2â¿) â†’ n < 25æ‰èƒ½ç®—
â€¢ O(n!) â†’ n < 11æ‰èƒ½ç®—
```

## ğŸ”— ä¸å…¶ä»–æ¦‚å¿µçš„è”ç³»

### ä¸æ•°æ®ç»“æ„
- **æ•°ç»„** - O(1)è®¿é—®ï¼ŒO(n)æœç´¢
- **é“¾è¡¨** - O(1)æ’å…¥ï¼ŒO(n)è®¿é—®
- **æ ‘** - O(log n)æ“ä½œï¼ˆå¹³è¡¡æ—¶ï¼‰
- **å“ˆå¸Œè¡¨** - O(1)å¹³å‡æŸ¥æ‰¾

å‚è€ƒï¼š`fundamentals/data-structures/`

### ä¸ç®—æ³•
- **æ’åº** - æ¯”è¾ƒæ’åºä¸‹ç•Œ Î©(n log n)
- **æŸ¥æ‰¾** - äºŒåˆ†æŸ¥æ‰¾ O(log n)
- **åŠ¨æ€è§„åˆ’** - æ—¶ç©ºæƒè¡¡

å‚è€ƒï¼š`fundamentals/algorithms/`

### ä¸å¯è®¡ç®—æ€§
- **å¯è®¡ç®—æ€§** - èƒ½ä¸èƒ½ç®—
- **å¤æ‚åº¦** - å¤šå¿«èƒ½ç®—
- P vs NP - å¯è®¡ç®—ä½†å¯èƒ½å¾ˆæ…¢

å‚è€ƒï¼š`theory/computation-theory/computability.md`

## ğŸ“– æ‰©å±•é˜…è¯»

### é«˜çº§ä¸»é¢˜
- æ‘Šè¿˜åˆ†æ (Amortized Analysis)
- éšæœºç®—æ³•å¤æ‚åº¦
- å¹¶è¡Œç®—æ³•å¤æ‚åº¦
- ç¼“å­˜å¤æ‚åº¦æ¨¡å‹

### è¯æ˜æŠ€æœ¯
- é€’å½’æ ‘æ–¹æ³•
- æ›¿æ¢æ³•
- ä¸»å®šç†
- åŠ¿èƒ½æ³•

---

**æŒæ¡å¤æ‚åº¦åˆ†æï¼Œä½ å°±èƒ½è¯„ä¼°å’Œä¼˜åŒ–ç®—æ³•ï¼** â±ï¸

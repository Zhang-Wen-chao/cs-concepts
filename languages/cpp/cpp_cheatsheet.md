# C++ æ ¸å¿ƒå°æŠ„

> é˜¶æ®µ 1ï¼šç°ä»£ C++ åŸºç¡€ âœ…

---

## 00. ç°ä»£ C++ æ€ç»´

**äº”å¤§åŸåˆ™**ï¼š
1. RAIIï¼šæ„é€ è·å–ï¼Œææ„é‡Šæ”¾
2. æ™ºèƒ½æŒ‡é’ˆï¼šæ°¸è¿œä¸ new/delete
3. æ ‡å‡†å®¹å™¨ï¼šé»˜è®¤ vector
4. ç§»åŠ¨è¯­ä¹‰ï¼šè¿”å›å€¼è‡ªåŠ¨ç§»åŠ¨
5. const æ­£ç¡®æ€§ï¼šå‚æ•°ç”¨ const&

**const æŒ‡é’ˆ**ï¼ˆå£è¯€ï¼šconst åœ¨ * å·¦è¾¹å†…å®¹ä¸å˜ï¼Œå³è¾¹æŒ‡é’ˆä¸å˜ï¼‰
```cpp
const int* p      // æŒ‡å‘å¸¸é‡ï¼ˆå†…å®¹ä¸å¯å˜ï¼‰
int* const p      // å¸¸é‡æŒ‡é’ˆï¼ˆæŒ‡é’ˆä¸å¯å˜ï¼‰
```

---

## 01. RAII

**æ ¸å¿ƒ**ï¼šèµ„æºç”Ÿå‘½å‘¨æœŸç»‘å®šå¯¹è±¡ç”Ÿå‘½å‘¨æœŸ
- æ„é€ æ—¶è·å–èµ„æºï¼Œææ„æ—¶é‡Šæ”¾èµ„æº
- C++ ä¿è¯ï¼šç¦»å¼€ä½œç”¨åŸŸå¿…è°ƒç”¨ææ„ï¼Œå³ä½¿æœ‰å¼‚å¸¸

**Rule of 0/3/5**ï¼š
- **Rule of 0**ï¼šç”¨æ ‡å‡†åº“ï¼Œä»€ä¹ˆéƒ½ä¸å†™ï¼ˆæ¨èï¼‰âœ…
- **Rule of 5**ï¼šè‡ªå·±ç®¡ç†èµ„æºæ—¶ï¼Œå¿…é¡»å®šä¹‰ 5 ä¸ªå‡½æ•°
  ```cpp
  ~T();                      // 1. ææ„
  T(const T&);               // 2. æ‹·è´æ„é€ 
  T& operator=(const T&);    // 3. æ‹·è´èµ‹å€¼
  T(T&&) noexcept;           // 4. ç§»åŠ¨æ„é€ 
  T& operator=(T&&) noexcept;// 5. ç§»åŠ¨èµ‹å€¼
  ```
- **Rule of 3**ï¼šC++11 å‰çš„æ—§è§„åˆ™ï¼Œå·²è¿‡æ—¶

**ç¦æ­¢æ‹·è´çš„æ–¹å¼**ï¼š
```cpp
T(const T&) = delete;
T& operator=(const T&) = delete;
```

**noexcept å…³é”®ç‚¹**ï¼š
- `noexcept` æ˜¯ç¨‹åºå‘˜çš„æ‰¿è¯ºï¼Œä¸æ˜¯ç¼–è¯‘å™¨æ£€æŸ¥
- è¿åæ‰¿è¯º â†’ è¿è¡Œæ—¶ `std::terminate`ï¼Œç¨‹åºå´©æºƒ
- ç§»åŠ¨å‡½æ•°å¿…é¡» `noexcept`ï¼Œå¦åˆ™ vector æ‰©å®¹æ—¶é€€åŒ–ä¸ºæ‹·è´
- ææ„å‡½æ•°é»˜è®¤å°±æ˜¯ `noexcept`ï¼Œç»å¯¹ä¸èƒ½æŠ›å¼‚å¸¸

**RAII ç±»å‹**ï¼š
- å†…å­˜ï¼š`unique_ptr`, `shared_ptr`, `vector`, `string`
- æ–‡ä»¶ï¼š`ifstream`, `ofstream`, `fstream`
- é”ï¼š`lock_guard`, `unique_lock`, `scoped_lock`
- çº¿ç¨‹ï¼š`thread`, `jthread`(C++20)

---

## 02. æ™ºèƒ½æŒ‡é’ˆ

**ä¸‰ç§ç±»å‹**ï¼š
```cpp
unique_ptr  // ç‹¬å æ‰€æœ‰æƒï¼Œ90%æƒ…å†µï¼Œåªèƒ½ç§»åŠ¨ï¼Œé›¶å¼€é”€
shared_ptr  // å…±äº«æ‰€æœ‰æƒï¼Œå¼•ç”¨è®¡æ•°ï¼Œå¯æ‹·è´
weak_ptr    // ä¸æ‹¥æœ‰ï¼Œä¸å¢åŠ å¼•ç”¨è®¡æ•°ï¼Œæ‰“ç ´å¾ªç¯å¼•ç”¨
```

**åˆ›å»ºæ–¹å¼**ï¼š
```cpp
auto p = std::make_unique<int>(42);   // unique_ptrï¼ˆæ¨èï¼‰
auto sp = std::make_shared<int>(42);  // shared_ptrï¼ˆæ¨èï¼‰
auto arr = std::make_unique<int[]>(100); // æ•°ç»„

// âŒ ä¸æ¨è
std::unique_ptr<int> p(new int(42));  // ä¸å¦‚ make_unique å®‰å…¨
std::shared_ptr<int> sp(new int(42)); // ä¸¤æ¬¡å†…å­˜åˆ†é…ï¼Œæ…¢
```

**unique_ptr**ï¼š
```cpp
auto p2 = std::move(p1);  // ç§»åŠ¨æ‰€æœ‰æƒï¼Œp1 å˜ç©º
int* raw = p.get();       // è·å–åŸå§‹æŒ‡é’ˆï¼ˆä¸è½¬ç§»æ‰€æœ‰æƒï¼‰
```

**shared_ptr**ï¼š
```cpp
auto p2 = p1;              // æ‹·è´ï¼Œå¼•ç”¨è®¡æ•° +1
p1.use_count();            // æŸ¥è¯¢å¼•ç”¨è®¡æ•°
p1.reset();                // å¼•ç”¨è®¡æ•° -1
```

**weak_ptrï¼ˆæ‰“ç ´å¾ªç¯å¼•ç”¨ï¼‰**ï¼š
```cpp
// âŒ å¾ªç¯å¼•ç”¨ä¼šå†…å­˜æ³„æ¼
struct Node {
    std::shared_ptr<Node> next;  // å¼ºå¼•ç”¨
    std::shared_ptr<Node> prev;  // ä¹Ÿå¼ºå¼•ç”¨ ğŸ’¥ å¾ªç¯äº†
};

// âœ… ç”¨ weak_ptr æ‰“ç ´å¾ªç¯
struct Node {
    std::shared_ptr<Node> next;  // å¼ºå¼•ç”¨
    std::weak_ptr<Node> prev;    // å¼±å¼•ç”¨ âœ…
};

// ä½¿ç”¨ weak_ptr
std::weak_ptr<int> wp = sp;  // ä¸å¢åŠ å¼•ç”¨è®¡æ•°
if (auto tmp = wp.lock()) {  // lock() è½¬ä¸º shared_ptr
    // ä½¿ç”¨ tmp
}
```

**åŒå‘å¼•ç”¨è§„åˆ™**ï¼š
- æ‹¥æœ‰æ–¹ â†’ è¢«æ‹¥æœ‰æ–¹ï¼š`shared_ptr`
- è¢«æ‹¥æœ‰æ–¹ â†’ æ‹¥æœ‰æ–¹ï¼š`weak_ptr`
- ä¾‹å­ï¼šçˆ¶æ‹¥æœ‰å­ï¼ˆ`shared_ptr`ï¼‰ï¼Œå­å¼•ç”¨çˆ¶ï¼ˆ`weak_ptr`ï¼‰

**å¸¸è§é™·é˜±**ï¼š
```cpp
// âŒ åŒä¸€ä¸ªè£¸æŒ‡é’ˆåˆå§‹åŒ–å¤šä¸ªæ™ºèƒ½æŒ‡é’ˆï¼ˆé‡å¤é‡Šæ”¾ï¼‰
int* raw = new int(42);
std::unique_ptr<int> p1(raw);
std::unique_ptr<int> p2(raw);  // ğŸ’¥

// âŒ ä» get() å†åˆ›å»ºæ™ºèƒ½æŒ‡é’ˆï¼ˆé‡å¤é‡Šæ”¾ï¼‰
auto p1 = std::make_unique<int>(42);
std::unique_ptr<int> p2(p1.get());  // ğŸ’¥
```

**å‡½æ•°å‚æ•°ä¼ é€’**ï¼š
```cpp
void use_only(T& obj);                    // åªä½¿ç”¨ï¼Œä¸å…³å¿ƒæ‰€æœ‰æƒ
void take_ownership(std::unique_ptr<T> p); // è½¬ç§»æ‰€æœ‰æƒ
void share(std::shared_ptr<T> p);          // å…±äº«æ‰€æœ‰æƒ
void observe(const std::shared_ptr<T>& p); // ä¸æ”¹å˜å¼•ç”¨è®¡æ•°
```

---

## 03. å®¹å™¨

**é€‰æ‹©æŒ‡å—**ï¼ˆ90% æƒ…å†µï¼‰ï¼š
```cpp
vector           // é»˜è®¤é€‰æ‹©ï¼ˆé¡ºåºå­˜å‚¨ï¼Œéšæœºè®¿é—®ï¼‰
unordered_map    // é”®å€¼æŸ¥æ‰¾ O(1)
unordered_set    // å»é‡ O(1)
```

**å†³ç­–æ ‘**ï¼š
```
éœ€è¦é”®å€¼å¯¹ï¼Ÿ
  æ˜¯ â†’ unordered_map
  å¦ â†’ éœ€è¦å»é‡ï¼Ÿ
         æ˜¯ â†’ unordered_set
         å¦ â†’ vectorï¼ˆé»˜è®¤ï¼‰
```

**vectorï¼ˆé»˜è®¤é€‰æ‹©ï¼‰**ï¼š
```cpp
std::vector<int> v = {1, 2, 3};
v.push_back(4);          // æœ«å°¾æ·»åŠ ï¼ˆæ„é€ ä¸´æ—¶å¯¹è±¡å†ç§»åŠ¨ï¼‰
v.emplace_back(5);       // æœ«å°¾åŸåœ°æ„é€ ï¼ˆæ›´å¿«ï¼Œé¿å…ç§»åŠ¨ï¼‰
v[0] = 10;               // éšæœºè®¿é—® O(1)
v.reserve(1000);         // é¢„ç•™å®¹é‡ï¼Œé¿å…é‡å¤æ‰©å®¹
v.size();                // å½“å‰å…ƒç´ æ•°é‡
v.empty();               // æ˜¯å¦ä¸ºç©º
v.clear();               // æ¸…ç©º
```

**unordered_mapï¼ˆé”®å€¼æŸ¥æ‰¾ï¼‰**ï¼š
```cpp
std::unordered_map<std::string, int> m;
m["apple"] = 5;          // æ’å…¥/ä¿®æ”¹
int val = m["apple"];    // è®¿é—®ï¼ˆä¸å­˜åœ¨ä¼šåˆ›å»ºé»˜è®¤å€¼ï¼‰
m.erase("apple");        // åˆ é™¤
if (m.count("key")) {}   // æ£€æŸ¥æ˜¯å¦å­˜åœ¨ï¼ˆè¿”å› 0 æˆ– 1ï¼‰
// C++20: if (m.contains("key")) {}
```

**unordered_setï¼ˆå»é‡ï¼‰**ï¼š
```cpp
std::unordered_set<int> s = {1, 2, 3, 2, 1};  // è‡ªåŠ¨å»é‡
s.insert(4);             // æ’å…¥
s.erase(2);              // åˆ é™¤
if (s.count(3)) {}       // æ£€æŸ¥æ˜¯å¦å­˜åœ¨
```

**é€šç”¨æ“ä½œ**ï¼š
```cpp
// éå†ï¼ˆé€‚ç”¨æ‰€æœ‰å®¹å™¨ï¼‰
for (const auto& item : container) { /* ... */ }

// å¤§å°
container.size();
container.empty();
container.clear();
```

**æ—¶é—´å¤æ‚åº¦**ï¼š
| å®¹å™¨ | æŸ¥æ‰¾ | æ’å…¥ | åˆ é™¤ |
|-----|------|------|------|
| vector | O(n) | O(1)å°¾éƒ¨ | O(1)å°¾éƒ¨ |
| unordered_map | O(1) | O(1) | O(1) |
| unordered_set | O(1) | O(1) | O(1) |
| mapï¼ˆæœ‰åºï¼‰ | O(log n) | O(log n) | O(log n) |

---

## 04. ç§»åŠ¨è¯­ä¹‰

**æ ¸å¿ƒæ¦‚å¿µ**ï¼šç§»åŠ¨ = è½¬ç§»æ‰€æœ‰æƒï¼Œä¸æ‹·è´æ•°æ®ï¼ˆO(1)ï¼‰

**å·¦å€¼ vs å³å€¼**ï¼š
```cpp
int x = 10;
//  â†‘   â†‘
// å·¦å€¼ å³å€¼

// å·¦å€¼ï¼šæœ‰åå­—ï¼Œå¯ä»¥å–åœ°å€
int a = 5;  int* p = &a;  // âœ…

// å³å€¼ï¼šä¸´æ—¶å¯¹è±¡ï¼Œä¸èƒ½å–åœ°å€
int b = 10 + 20;  // 10 + 20 æ˜¯å³å€¼
// int* p = &(10 + 20);  // âŒ

// å³å€¼é©¬ä¸Šé”€æ¯ â†’ å¯ä»¥"å·"èµ°èµ„æºï¼ˆç§»åŠ¨ï¼‰
```

**å…­ä¸ªç‰¹æ®Šæˆå‘˜å‡½æ•°**ï¼š
```cpp
Widget w1;           // 1. é»˜è®¤æ„é€ 
Widget w2(w1);       // 2. æ‹·è´æ„é€ ï¼ˆåˆ›å»ºæ–°å¯¹è±¡ï¼Œfrom å·¦å€¼ï¼‰
w3 = w1;             // 3. æ‹·è´èµ‹å€¼ï¼ˆå·²å­˜åœ¨å¯¹è±¡ï¼Œfrom å·¦å€¼ï¼‰
Widget w4(move(w1)); // 4. ç§»åŠ¨æ„é€ ï¼ˆåˆ›å»ºæ–°å¯¹è±¡ï¼Œfrom å³å€¼ï¼‰
w4 = move(w2);       // 5. ç§»åŠ¨èµ‹å€¼ï¼ˆå·²å­˜åœ¨å¯¹è±¡ï¼Œfrom å³å€¼ï¼‰
                     // 6. ææ„
```

**ç§»åŠ¨æ„é€ /ç§»åŠ¨èµ‹å€¼å®ç°**ï¼š
```cpp
class MyVector {
    int* data_;
    size_t size_;
public:
    // ç§»åŠ¨æ„é€ 
    MyVector(MyVector&& o) noexcept
        : data_(o.data_), size_(o.size_) {
        o.data_ = nullptr;  // "å·"èµ°èµ„æºï¼Œæç©ºåŸå¯¹è±¡
        o.size_ = 0;
    }

    // ç§»åŠ¨èµ‹å€¼
    MyVector& operator=(MyVector&& o) noexcept {
        if (this != &o) {
            delete[] data_;       // é‡Šæ”¾æ—§èµ„æº
            data_ = o.data_;      // å·èµ°æ–°èµ„æº
            size_ = o.size_;
            o.data_ = nullptr;    // æç©ºåŸå¯¹è±¡
            o.size_ = 0;
        }
        return *this;
    }
};
```

**std::move**ï¼š
```cpp
// std::move ä¸ç§»åŠ¨ï¼Œåªæ˜¯ç±»å‹è½¬æ¢ï¼ˆå·¦å€¼ â†’ å³å€¼å¼•ç”¨ï¼‰
std::string s1 = "hello";
std::string s2 = std::move(s1);  // å¼ºåˆ¶ç§»åŠ¨ï¼Œs1 è¢«æç©º

// âš ï¸ ç§»åŠ¨åä¸è¦å†ç”¨åŸå¯¹è±¡
// std::cout << s1;  // å±é™©
```

**ä½•æ—¶ç”¨ std::move**ï¼š
```cpp
// âœ… è½¬ç§»æ‰€æœ‰æƒ
std::string s2 = std::move(s1);

// âœ… å®¹å™¨ä¸­ç§»åŠ¨å…ƒç´ 
vec.push_back(std::move(s));

// âŒ è¿”å›å±€éƒ¨å˜é‡æ—¶ä¸è¦ç”¨ï¼ˆå¦¨ç¢ RVOï¼‰
std::vector<int> foo() {
    std::vector<int> vec(1000);
    return std::move(vec);  // âŒ é”™è¯¯ï¼šç ´å RVO
}

// âœ… æ­£ç¡®ï¼šè®©ç¼–è¯‘å™¨è‡ªåŠ¨ä¼˜åŒ–
std::vector<int> foo() {
    std::vector<int> vec(1000);
    return vec;  // ç¼–è¯‘å™¨è‡ªåŠ¨ä¼˜åŒ–ï¼ˆRVO æˆ–ç§»åŠ¨ï¼‰
}
```

**RVOï¼ˆReturn Value Optimizationï¼‰**ï¼š
```
ç¼–è¯‘å™¨çš„è‡ªåŠ¨ä¼˜åŒ–ï¼šç›´æ¥åœ¨ç›®æ ‡ä½ç½®æ„é€ å¯¹è±¡ï¼Œé›¶æ‹·è´é›¶ç§»åŠ¨

æ€§èƒ½æ’åºï¼š
RVO/NRVOï¼ˆç¼–è¯‘å™¨ä¼˜åŒ–ï¼‰ > ç§»åŠ¨ > æ‹·è´
   O(0)               O(1)   O(n)
   é›¶å¼€é”€              å·æŒ‡é’ˆ   å¤åˆ¶æ•°æ®
```

**å¼•ç”¨ç±»å‹**ï¼š
```cpp
T&                // å·¦å€¼å¼•ç”¨ï¼ˆç»‘å®šæœ‰åå¯¹è±¡ï¼‰
const T&          // å¸¸é‡å¼•ç”¨ï¼ˆå‡½æ•°å‚æ•°é¦–é€‰ï¼‰
T&&               // å³å€¼å¼•ç”¨ï¼ˆç§»åŠ¨è¯­ä¹‰ï¼Œç»‘å®šä¸´æ—¶å¯¹è±¡ï¼‰
```

**å…³é”®è¦ç‚¹**ï¼š
- ç§»åŠ¨ = è½¬ç§»æ‰€æœ‰æƒ O(1)ï¼Œæ‹·è´ = å¤åˆ¶æ•°æ® O(n)
- è¿”å›å±€éƒ¨å˜é‡è‡ªåŠ¨ç§»åŠ¨/RVOï¼Œ**ä¸è¦å†™ std::move**
- ç§»åŠ¨åçš„å¯¹è±¡ä¸è¦å†ç”¨
- ç§»åŠ¨å‡½æ•°å¿…é¡»æ ‡è®° `noexcept`ï¼ˆå¦åˆ™ vector æ‰©å®¹ä¸ç”¨ç§»åŠ¨ï¼‰
- const å¯¹è±¡ä¸èƒ½ç§»åŠ¨ï¼ˆä¼šé€€åŒ–ä¸ºæ‹·è´ï¼‰

**å¸¸è§é™·é˜±**ï¼š
```cpp
// âŒ ä½¿ç”¨è¢«ç§»åŠ¨çš„å¯¹è±¡
std::string s2 = std::move(s1);
std::cout << s1;  // å±é™©

// âŒ const å¯¹è±¡ä¸èƒ½ç§»åŠ¨
const std::string s = "hello";
auto s2 = std::move(s);  // å®é™…æ˜¯æ‹·è´

// âŒ è¿”å›æ—¶ç”¨ std::move
return std::move(vec);  // å¦¨ç¢ RVO

// âŒ ç§»åŠ¨æ„é€ ç¼ºå°‘ noexcept
MyClass(MyClass&& o) { }  // vector æ‰©å®¹æ—¶ä¸ä¼šç”¨ç§»åŠ¨
```

---

## 05. Lambda

```cpp
[æ•è·](å‚æ•°) { å‡½æ•°ä½“ }
```

**æ•è·**ï¼š`[]` `[x]` `[&x]` `[=]` `[&]`

**ç¤ºä¾‹**ï¼š
```cpp
std::sort(v.begin(), v.end(), [](int a, int b) { return a > b; });
auto it = std::find_if(v.begin(), v.end(), [](int x) { return x > 5; });
```

---

## 06. æ¨¡æ¿

```cpp
template<typename T>           // å‡½æ•°æ¨¡æ¿ï¼ˆè‡ªåŠ¨æ¨å¯¼ï¼‰
template<typename T> class Box // ç±»æ¨¡æ¿ï¼ˆæ˜¾å¼æŒ‡å®šï¼‰
template<typename... Args>     // å˜é•¿æ¨¡æ¿
```

**ç¤ºä¾‹**ï¼š
```cpp
T max(T a, T b) { return a > b ? a : b; }
max(3, 5);  // è‡ªåŠ¨æ¨å¯¼ T = int

Box<int> b(42);  // ç±»æ¨¡æ¿å¿…é¡»æ˜¾å¼æŒ‡å®š
```

---

## å†™ä»£ç æ—¶è®°ä½

1. æ°¸è¿œä¸æ‰‹åŠ¨ new/delete
2. å‡½æ•°å‚æ•°ç”¨ const&
3. é»˜è®¤ç”¨ vector
4. ç§»åŠ¨å‡½æ•°æ ‡è®° noexcept
5. è¿”å›å€¼åˆ«å†™ std::move

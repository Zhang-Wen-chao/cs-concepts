# 指令集架构 (Instruction Set Architecture, ISA)

> 软件与硬件之间的契约

## 🎯 核心概念

指令集架构定义了**软件能看到的硬件抽象**，是处理器设计和程序开发之间的接口。

### ISA 定义了什么？

```
┌─────────────────────────────────────┐
│         应用程序                     │
│    (C/C++/Python/Java...)           │
└──────────────┬──────────────────────┘
               │ 编译
┌──────────────▼──────────────────────┐
│         汇编语言                     │
│    (mov, add, jmp...)               │
└──────────────┬──────────────────────┘
               │ 汇编
┌──────────────▼──────────────────────┐
│      指令集架构 (ISA)  ◄────────── 这一层！
│  • 指令格式                          │
│  • 寄存器                            │
│  • 寻址方式                          │
│  • 数据类型                          │
└──────────────┬──────────────────────┘
               │ 微架构实现
┌──────────────▼──────────────────────┐
│         硬件实现                     │
│    (晶体管、门电路...)              │
└─────────────────────────────────────┘
```

### 为什么重要？

- **兼容性**：同一 ISA 的不同处理器可以运行相同的程序
- **性能**：ISA 设计影响编译器优化和硬件效率
- **抽象**：隐藏硬件复杂性，简化软件开发

---

## 1️⃣ CISC vs RISC

### 两大设计哲学

```
┌──────────────────────────────────────────────┐
│  CISC: Complex Instruction Set Computer      │
│  复杂指令集 - 用硬件做更多事情                │
├──────────────────────────────────────────────┤
│  RISC: Reduced Instruction Set Computer      │
│  精简指令集 - 用简单指令组合复杂功能          │
└──────────────────────────────────────────────┘
```

### CISC (x86/x64)

**设计思想：用一条指令完成复杂操作**

```assembly
# x86 的一条指令可以做很多事
MUL EAX, [EBX + ECX*4 + 8]
  → 1. 计算地址: addr = EBX + ECX * 4 + 8
  → 2. 从内存读取数据
  → 3. 执行乘法
  → 4. 将结果写回 EAX

# 字符串操作指令
REP MOVSB
  → 重复执行字符串复制，直到 ECX = 0
```

**特点：**
```
✅ 优点:
  • 代码密度高（程序体积小）
  • 功能强大的指令
  • 向后兼容性好（x86 兼容 8086）

❌ 缺点:
  • 指令长度不固定（1-15 字节）
  • 译码复杂，硬件设计难
  • 不易流水线化
  • 编译器难以优化
```

### RISC (ARM, RISC-V, MIPS)

**设计思想：只提供简单、高频的指令**

```assembly
# RISC-V 需要多条指令完成相同功能
LW   t0, 8(a0)      # 1. 从内存加载
ADD  t1, a1, a2     # 2. 计算偏移
SLL  t1, t1, 2      # 3. 左移（乘以4）
ADD  t0, t0, t1     # 4. 计算地址
LW   t0, 0(t0)      # 5. 再次加载
MUL  a0, a0, t0     # 6. 执行乘法
```

**特点：**
```
✅ 优点:
  • 指令长度固定（通常32位）
  • 易于流水线化
  • 硬件设计简单
  • 编译器易优化
  • 能效比高（ARM 统治移动市场的原因）

❌ 缺点:
  • 代码密度低（程序体积大）
  • 指令数量多
```

### 现代趋势：CISC 和 RISC 融合

```
x86 处理器内部：
┌───────────────────────────────────┐
│  x86 指令 (CISC)                  │
└─────────────┬─────────────────────┘
              │ 译码
┌─────────────▼─────────────────────┐
│  微操作 (Micro-ops) ◄── RISC 风格 │
│  • 简单、固定长度                  │
│  • 易于流水线执行                  │
└───────────────────────────────────┘

现代 x86 = CISC 外表 + RISC 内核
```

---

## 2️⃣ 指令格式

### 指令的组成部分

```
┌──────────┬──────────┬──────────┬──────────┐
│  操作码  │  目的    │  源操作  │  源操作  │
│  Opcode  │  Dest    │  数 1    │  数 2    │
└──────────┴──────────┴──────────┴──────────┘
  告诉CPU   结果放    从哪里    从哪里
  做什么    哪里      取数据    取数据
```

### 实际例子

#### RISC-V (固定 32 位)
```
ADD x1, x2, x3
  → 寄存器 x1 = x2 + x3

指令编码（R-Type）：
┌──────┬─────┬─────┬─────┬──────┬──────┐
│ funct7│ rs2 │ rs1 │funct│ rd  │opcode│
│  7位 │ 5位 │ 5位 │ 3位 │ 5位 │ 7位  │
└──────┴─────┴─────┴─────┴──────┴──────┘
   0     x3    x2    0      x1    0x33
```

#### x86 (变长指令)
```
ADD EAX, EBX
  → 2 字节: 01 D8

ADD EAX, [EBX + 4]
  → 3 字节: 03 43 04

ADD EAX, [EBX + ECX*4 + 0x1000]
  → 7 字节: 03 84 8B 00 10 00 00
```

### 指令类型分类

#### 1. 数据传送指令
```assembly
# RISC-V
LW  x1, 0(x2)      # Load Word: x1 = Memory[x2]
SW  x1, 8(x2)      # Store Word: Memory[x2+8] = x1
MV  x1, x2         # Move: x1 = x2
```

#### 2. 算术逻辑指令
```assembly
# 算术运算
ADD  x1, x2, x3    # x1 = x2 + x3
SUB  x1, x2, x3    # x1 = x2 - x3
MUL  x1, x2, x3    # x1 = x2 * x3
DIV  x1, x2, x3    # x1 = x2 / x3

# 逻辑运算
AND  x1, x2, x3    # x1 = x2 & x3
OR   x1, x2, x3    # x1 = x2 | x3
XOR  x1, x2, x3    # x1 = x2 ^ x3
NOT  x1, x2        # x1 = ~x2

# 移位运算
SLL  x1, x2, 4     # x1 = x2 << 4  (逻辑左移)
SRL  x1, x2, 4     # x1 = x2 >> 4  (逻辑右移)
```

#### 3. 控制转移指令
```assembly
# 无条件跳转
J    label         # 跳转到 label
JAL  x1, func      # 跳转到 func，返回地址存入 x1

# 条件分支
BEQ  x1, x2, label # if (x1 == x2) goto label
BNE  x1, x2, label # if (x1 != x2) goto label
BLT  x1, x2, label # if (x1 < x2) goto label
```

---

## 3️⃣ 寻址方式

### 操作数在哪里？

```
指令需要数据，数据可能在：
  1. 立即数（指令中）
  2. 寄存器
  3. 内存
```

### 1. 立即数寻址 (Immediate)
```assembly
ADDI x1, x2, 10     # x1 = x2 + 10
                    # "10" 直接编码在指令中

使用场景：常量、小数值
```

### 2. 寄存器寻址 (Register)
```assembly
ADD x1, x2, x3      # x1 = x2 + x3
                    # 所有操作数都在寄存器

特点：最快的寻址方式（<1ns）
```

### 3. 直接寻址 (Direct / Absolute)
```assembly
LW  x1, 0x1000      # x1 = Memory[0x1000]
                    # 直接指定内存地址

使用场景：全局变量
```

### 4. 间接寻址 (Indirect)
```assembly
LW  x1, 0(x2)       # x1 = Memory[x2]
                    # 地址存在寄存器 x2 中

使用场景：指针访问
C 代码: int val = *ptr;
```

### 5. 基址+偏移寻址 (Base + Offset)
```assembly
LW  x1, 8(x2)       # x1 = Memory[x2 + 8]
                    # 基址寄存器 + 常量偏移

使用场景：数组、结构体
C 代码: int val = array[2];  // sizeof(int) = 4
```

### 6. 变址寻址 (Indexed)
```assembly
# x86 支持
MOV EAX, [EBX + ECX*4 + 8]
  → 地址 = EBX + ECX * 4 + 8
  → EAX = Memory[地址]

使用场景：数组访问
C 代码: int val = base[index];
```

### 7. PC 相对寻址 (PC-Relative)
```assembly
BEQ x1, x2, label   # if (x1 == x2) goto (PC + offset)
                    # 相对当前指令地址

使用场景：条件分支、函数调用
优点：位置无关代码（PIC）
```

### 寻址方式对比

```
┌──────────────┬──────┬────────────────────┐
│  寻址方式    │ 速度 │  典型用途          │
├──────────────┼──────┼────────────────────┤
│ 寄存器       │ 最快 │ 临时变量、循环变量  │
│ 立即数       │ 快   │ 常量               │
│ 基址+偏移    │ 中   │ 数组、结构体        │
│ 间接         │ 慢   │ 指针、动态数据      │
│ 变址         │ 慢   │ 多维数组           │
└──────────────┴──────┴────────────────────┘
```

---

## 4️⃣ 寄存器组织

### 什么是寄存器？

**寄存器 = CPU 内部的超高速存储单元**

```
速度对比：
  寄存器访问：<1 纳秒
  L1 Cache：  ~1 纳秒
  内存访问：  ~100 纳秒

寄存器比内存快 100 倍！
```

### RISC-V 寄存器（32个通用寄存器）

```
┌──────┬──────┬─────────────────────────────┐
│ 编号 │ 名称 │  用途（ABI 约定）           │
├──────┼──────┼─────────────────────────────┤
│ x0   │ zero │  硬连线为 0，永远是 0       │
│ x1   │ ra   │  返回地址 (Return Address)  │
│ x2   │ sp   │  栈指针 (Stack Pointer)     │
│ x3   │ gp   │  全局指针 (Global Pointer)  │
│ x4   │ tp   │  线程指针 (Thread Pointer)  │
│ x5-7 │ t0-2 │  临时寄存器（调用者保存）    │
│ x8   │ s0/fp│  保存寄存器/帧指针          │
│ x9   │ s1   │  保存寄存器（被调用者保存）  │
│ x10-11│a0-1 │  函数参数 / 返回值          │
│ x12-17│a2-7 │  函数参数                   │
│ x18-27│s2-11│  保存寄存器（被调用者保存）  │
│ x28-31│t3-6 │  临时寄存器                 │
└──────┴──────┴─────────────────────────────┘

特殊之处：
  • x0 永远是 0（简化指令设计）
  • 没有专用的"累加器"（对称设计）
```

### x86-64 寄存器（历史包袱）

```
┌────────┬─────────────────────────────────┐
│ 64位   │  低32位  │  低16位 │  用途     │
├────────┼──────────┼─────────┼───────────┤
│ RAX    │  EAX     │  AX     │ 累加器    │
│ RBX    │  EBX     │  BX     │ 基址      │
│ RCX    │  ECX     │  CX     │ 计数器    │
│ RDX    │  EDX     │  DX     │ 数据      │
│ RSI    │  ESI     │  SI     │ 源索引    │
│ RDI    │  EDI     │  DI     │ 目的索引  │
│ RBP    │  EBP     │  BP     │ 基址指针  │
│ RSP    │  ESP     │  SP     │ 栈指针    │
│ R8-R15 │  R8D-R15D│  R8W-R15W│ 通用     │
└────────┴──────────┴─────────┴───────────┘

向后兼容：
  • RAX 的低 32 位是 EAX
  • EAX 的低 16 位是 AX
  • AX 可以分为 AH (高8位) 和 AL (低8位)
```

### 寄存器使用约定（调用约定）

#### 函数调用时寄存器如何使用？

```c
int foo(int a, int b) {
    int x = a + b;
    return x * 2;
}

int main() {
    int result = foo(3, 5);
    return result;
}
```

**RISC-V 汇编实现：**
```assembly
# main 函数
main:
    addi sp, sp, -16       # 分配栈空间
    sw   ra, 12(sp)        # 保存返回地址

    li   a0, 3             # 第一个参数 → a0
    li   a1, 5             # 第二个参数 → a1
    call foo               # 调用函数

    # 返回值在 a0 中
    lw   ra, 12(sp)        # 恢复返回地址
    addi sp, sp, 16        # 释放栈空间
    ret

# foo 函数
foo:
    add  a0, a0, a1        # x = a + b
    slli a0, a0, 1         # x = x * 2 (左移1位 = 乘2)
    ret                    # 返回（结果在 a0）
```

**寄存器保存责任：**
```
调用者保存 (Caller-saved)：
  • a0-a7：参数寄存器
  • t0-t6：临时寄存器
  → 调用函数前，调用者要保存这些寄存器

被调用者保存 (Callee-saved)：
  • s0-s11：保存寄存器
  → 被调用函数要保证返回时这些寄存器不变
```

---

## 5️⃣ 汇编语言基础

### 汇编与机器码的关系

```
高级语言 (C):
    int a = b + c;

汇编语言 (RISC-V):
    ADD x1, x2, x3

机器码 (二进制):
    0000000 00011 00010 000 00001 0110011

16进制:
    0x003100B3
```

### 汇编程序结构

```assembly
# RISC-V 汇编示例
.data                          # 数据段
    msg: .string "Hello\n"     # 字符串
    arr: .word 1, 2, 3, 4      # 整数数组
    val: .word 42              # 单个整数

.text                          # 代码段
.globl main                    # 声明全局符号

main:
    # 函数入口
    addi sp, sp, -16           # 分配栈帧
    sw   ra, 12(sp)            # 保存返回地址

    # 函数体
    la   a0, msg               # 加载字符串地址
    call print_string          # 调用函数

    # 函数出口
    lw   ra, 12(sp)            # 恢复返回地址
    addi sp, sp, 16            # 释放栈帧
    li   a0, 0                 # 返回 0
    ret                        # 返回
```

### 常见汇编指令模式

#### 1. 函数调用
```assembly
# 保存现场
addi sp, sp, -16
sw   ra, 12(sp)
sw   s0, 8(sp)

# 调用函数
call function

# 恢复现场
lw   s0, 8(sp)
lw   ra, 12(sp)
addi sp, sp, 16
ret
```

#### 2. 条件分支
```c
// C 代码
if (a == b) {
    x = 1;
} else {
    x = 2;
}
```

```assembly
# RISC-V 汇编
    bne  a0, a1, else_branch   # if (a != b) goto else
    li   a2, 1                 # x = 1
    j    end_if
else_branch:
    li   a2, 2                 # x = 2
end_if:
```

#### 3. 循环
```c
// C 代码
for (int i = 0; i < 10; i++) {
    sum += i;
}
```

```assembly
# RISC-V 汇编
    li   t0, 0                 # i = 0
    li   t1, 10                # limit = 10
    li   t2, 0                 # sum = 0
loop:
    bge  t0, t1, end_loop      # if (i >= 10) break
    add  t2, t2, t0            # sum += i
    addi t0, t0, 1             # i++
    j    loop
end_loop:
```

---

## 6️⃣ 实际应用

### 为什么程序员要了解 ISA？

#### 1. 性能优化
```c
// 低效代码（除法慢）
int divide_by_8(int x) {
    return x / 8;
}

// 编译器优化为（右移快）
int divide_by_8_opt(int x) {
    return x >> 3;  // 除以 2^3 = 8
}

// 汇编：
SRL x1, x0, 3      # 一条指令！
```

#### 2. 理解编译器行为
```c
// C 代码
int arr[100];
for (int i = 0; i < 100; i++) {
    arr[i] = 0;
}

// 编译器可能优化为
memset(arr, 0, 400);  // 一次系统调用

// 或使用向量化指令（SIMD）
// 一次清零 4 个整数
```

#### 3. 调试和逆向工程
- 阅读汇编代码理解程序行为
- 分析性能瓶颈
- 安全漏洞分析

### ISA 对性能的影响

```
相同功能，不同 ISA 的性能：

字符串复制（1000字节）:
┌──────────┬──────────────┬─────────┐
│   ISA    │  指令数      │  周期   │
├──────────┼──────────────┼─────────┤
│ x86      │  1 (REP MOVSB)│  ~1000  │
│ RISC-V   │  ~5000       │  ~5000  │
└──────────┴──────────────┴─────────┘

但：
  • RISC-V 频率可以更高（设计简单）
  • RISC-V 功耗更低
  • 实际性能取决于微架构实现
```

---

## 🔗 与其他概念的联系

### 与编译器
- **代码生成** - 编译器将高级语言翻译为 ISA 指令
- **寄存器分配** - 编译器决定变量使用哪些寄存器
- **指令选择** - 选择最优的指令序列

### 与操作系统
- **系统调用** - OS 通过特殊指令进入内核
- **异常处理** - ISA 定义中断、异常机制
- **特权级别** - 用户态/内核态切换

参考：`systems/operating-systems/`

### 与微架构
- **ISA = 规范** - 定义"做什么"
- **微架构 = 实现** - 定义"怎么做"
- 同一 ISA 可以有不同微架构实现

参考：`./pipelining-parallelism.md`

---

## 📚 深入学习

### 推荐资源
- *Computer Organization and Design* (Patterson & Hennessy)
- RISC-V Spec（开放标准）
- Intel/AMD 指令集手册

### 实践项目
- 学习 RISC-V 汇编编程
- 阅读编译器生成的汇编代码
- 实现简单的汇编器

### 下一步
- [存储层次结构](./memory-hierarchy.md) - 理解 Load/Store 性能
- [流水线](./pipelining-parallelism.md) - 理解指令执行过程
- [性能评估](./performance-evaluation.md) - 量化 ISA 影响

---

**理解 ISA，就理解了软件与硬件的桥梁！** 🌉
